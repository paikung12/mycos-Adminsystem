(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.UseTheForm = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function mergeValidators(path, value, clean) {
    var newValidators = {};

    if (_typeof(value) === "object" && value !== null) {
      newValidators = Object.keys(value).reduce(function (acc, key) {
        if (clean) {
          acc["".concat(path, "/").concat(key)] = undefined;
        } else if (value[key] !== undefined) {
          acc["".concat(path, "/").concat(key)] = value[key];
        }

        return acc;
      }, {});
    } else if (typeof value === "function") {
      newValidators = clean ? _defineProperty({}, path, undefined) : _defineProperty({}, path, value);
    } else if (typeof value === "boolean" || value === null) {
      // typeof value === "boolean" || value === null only for async validators
      // value === null if it is an asycn func added on a Collection
      var pathValue = value === null ? {
        type: "collection",
        isValid: value,
        counter: 0
      } : {
        type: "field",
        isValid: value,
        counter: 0
      };
      newValidators = clean ? _defineProperty({}, path, undefined) : _defineProperty({}, path, pathValue);
    }

    return newValidators;
  }

  function useValidators(context, nameProp, isMounted) {
    var isAsync = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var validators = React.useRef({});
    var validatorsMaps = React.useRef({});
    var updateValidatorsMap = React.useCallback(function (path, isValid, counter) {
      // It propagates up to the form context
      if (context !== undefined) {
        context.updateValidatorsMap("".concat(nameProp.current, "/").concat(path), isValid, counter);
      } else {
        validatorsMaps.current[path] = _objectSpread2(_objectSpread2({}, validatorsMaps.current[path]), {}, {
          isValid: isValid,
          counter: counter
        });
      }
    }, []); // resetValidatorsMap only used in useForm

    var resetValidatorsMap = React.useCallback(function () {
      Object.keys(validatorsMaps.current).forEach(function (key) {
        var type = validatorsMaps.current[key].type;
        validatorsMaps.current[key].counter = 0;
        validatorsMaps.current[key].isValid = type === "collection" ? null : false;
      });
      return validatorsMaps.current;
    }, []); // syncValidatorsValue type depends on its context - can be function or object
    // asyncValidatorsValue type depends on its context - can be boolean, null or object

    var _useRef = React.useRef(function (path, syncValidatorsValue, asyncValidatorsValue) {
      validators.current = _objectSpread2(_objectSpread2({}, validators.current), mergeValidators(path, syncValidatorsValue));

      if (isAsync) {
        validatorsMaps.current = _objectSpread2(_objectSpread2({}, validatorsMaps.current), mergeValidators(path, asyncValidatorsValue));
      }

      if (nameProp !== undefined && isMounted.current && context !== undefined) {
        var addFN = isAsync ? context.addValidatorsAsync : context.addValidators;
        addFN(nameProp.current, validators.current, validatorsMaps.current);
      }
    }),
        addValidators = _useRef.current;

    var _useRef2 = React.useRef(function (path, validatorsToRemove) {
      var validatorsMapsToRemove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var newValidators = _objectSpread2(_objectSpread2({}, validators.current), mergeValidators(path, validatorsToRemove, true));

      var newValidatorsMaps = !isAsync ? {} : _objectSpread2(_objectSpread2({}, validatorsMaps.current), mergeValidators(path, validatorsMapsToRemove, true));

      if (context !== undefined) {
        validators.current = newValidators;
        validatorsMaps.current = newValidatorsMaps;
        var removeFN = isAsync ? context.removeValidatorsAsync : context.removeValidators;
        removeFN(nameProp.current, validators.current, validatorsMaps.current);
      } else {
        // if context is undefined it is the form context and then
        // we must clean the undefined prop from it
        validators.current = cleanValidators(newValidators);
        validatorsMaps.current = cleanValidators(newValidatorsMaps);
      }
    }),
        removeValidators = _useRef2.current;

    return [validators, addValidators, removeValidators, validatorsMaps, updateValidatorsMap, resetValidatorsMap];
  }

  function cleanValidators(validatorObj) {
    Object.keys(validatorObj).forEach(function (key) {
      if (validatorObj[key] === undefined) {
        delete validatorObj[key];
      }
    });
    return validatorObj;
  }

  function useMapFields(nameProp, context) {
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "object";
    var mapFields = React.useRef({});
    var updateRegisteredField = React.useCallback(function (propName, map) {
      mapFields.current[propName] = map;
    }, []);
    var unRegisterField = React.useCallback(function (propName) {
      var _context$updateRegist;

      delete mapFields.current[propName];

      if (type === "array") {
        mapFields.current = keepIndexSync(mapFields.current);
      }

      context === null || context === void 0 ? void 0 : (_context$updateRegist = context.updateRegisteredField) === null || _context$updateRegist === void 0 ? void 0 : _context$updateRegist.call(context, nameProp.current, mapFields.current);
    }, []);
    return {
      unRegisterField: unRegisterField,
      mapFields: mapFields,
      updateRegisteredField: updateRegisteredField
    };
  }

  function keepIndexSync(map) {
    var keys = Object.keys(map);
    var mySelfKey = keys[keys.length - 1];
    var mySelfVal = map[mySelfKey];
    keys.pop();
    var newMapArray = keys.map(function (key) {
      return map[key];
    });
    return newMapArray.reduce(function (acc, val, index) {
      acc[index] = val;
      return acc;
    }, _defineProperty({}, mySelfKey, mySelfVal));
  }

  function passValidation(value) {
    var validators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var formState = arguments.length > 2 ? arguments[2] : undefined;
    var checks = validators.map(function (fn) {
      return fn(value, formState);
    });
    var isValid = checks.every(function (val) {
      return val === undefined || val === null;
    });
    return {
      checks: checks,
      isValid: isValid
    };
  }

  function getValidationMsg(errors) {
    // It uses filter over find for supporting IE 11
    return errors.filter(function (e) {
      return e !== undefined && e !== null;
    })[0];
  }

  function useValidationFunction() {
    var validators = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var validationMsg = React.useRef(undefined);
    var validationObj = React.useRef(null);
    var validationFN = React.useRef(function (value, stateForm) {
      var _passValidation = passValidation(value, validators, stateForm),
          isValid = _passValidation.isValid,
          checks = _passValidation.checks;

      validationMsg.current = getValidationMsg(checks);
      validationObj.current = {
        isValid: isValid,
        checks: checks
      };
      return isValid;
    });
    return {
      validationMsg: validationMsg,
      validationObj: validationObj,
      validationFN: validationFN
    };
  }

  function useValidationFunctionAsync(asyncValidator, onAsyncValidation) {
    var validationMsg = React.useRef(undefined);
    var timestampAsyncFunc = React.useRef(null);
    var validationFN = React.useRef(function (value) {
      var newValue = value === undefined ? "" : value;
      var timestamp = Date.now();
      timestampAsyncFunc.current = timestamp;
      onAsyncValidation({
        status: "asyncStart"
      });
      return new Promise(function (resolve, reject) {
        asyncValidator(newValue).then(function (value) {
          if (timestampAsyncFunc.current === timestamp) {
            validationMsg.current = value;
            onAsyncValidation({
              status: "asyncSuccess",
              value: value
            });
            resolve(value);
          } else {
            reject("cancelled");
          }
        })["catch"](function (value) {
          if (timestampAsyncFunc.current === timestamp) {
            validationMsg.current = value;
            onAsyncValidation({
              status: "asyncError",
              value: value
            });
            reject(value);
          } else {
            reject("cancelled");
          }
        });
      });
    });
    return [validationFN];
  }

  function updateState(state, _ref) {
    var nameProp = _ref.nameProp,
        value = _ref.value,
        removeMe = _ref.removeMe,
        _ref$add = _ref.add,
        add = _ref$add === void 0 ? false : _ref$add;
    var isArray = state.constructor === Array; // it uses slice over spread operator to avoid [undefined , anyvalue] and use [empty , anyvalue]

    var newState = isArray ? state.slice() : _objectSpread2({}, state);

    if (add && isArray && typeof newState[nameProp] !== "undefined") {
      newState.splice(nameProp, 0, value);
    } else {
      newState[nameProp] = value;
    }

    if (removeMe || value === undefined || value === null || value.constructor === Array && value.every(function (elm) {
      return elm === undefined;
    }) || _typeof(value) === "object" && value.constructor.name !== "File" && Object.keys(value).length === 0 || typeof value === "string" && value === "") {
      delete newState[nameProp];
    }

    return newState;
  }

  var noop = function noop(val) {
    return val;
  };

  function chainReducers() {
    var reducers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (typeof reducers === "function") {
      return reducers;
    }

    return reducers.length === 0 ? noop : function (newValue, oldValue, state) {
      return reducers.reduce(function (acc, elm, index) {
        return index > 0 ? elm(acc, oldValue, state) : acc;
      }, reducers[0](newValue, oldValue, state));
    };
  }

  var STATUS = {
    ON_RESET: "ON_RESET",
    READY: "READY",
    RESETTED: "RESETTED",
    ON_CHANGE: "ON_CHANGE",
    ON_INIT: "ON_INIT",
    ON_SUBMIT: "ON_SUBMIT",
    ON_INIT_ASYNC: "ON_INIT_ASYNC",
    ON_RUN_ASYNC: "ON_RUN_ASYNC",
    ON_ASYNC_END: "ON_ASYNC_END"
  };
  var DISPATCHER_LABEL = "__$$USETHEFORM_DISPATCHER$$__";
  var FORM_VALIDATION_LABEL = "__$$USETHEFORM_VALIDATION$$__";

  var createForm = function createForm() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return {
      state: state,
      isValid: true,
      status: STATUS.READY,
      pristine: true,
      isSubmitting: false,
      submitAttempts: 0,
      submitted: 0
    };
  };
  var getValueByPath = function getValueByPath(path, obj) {
    var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "/";

    if (path === FORM_VALIDATION_LABEL) {
      return obj;
    }

    var properties = Array.isArray(path) ? path : path.split(separator);
    return properties.reduce(function (prev, curr) {
      return prev && prev[curr];
    }, obj);
  };
  var isFormValid = function isFormValid(validators, state) {
    return Object.keys(validators).reduce(function (acc, key) {
      var value = getValueByPath(key, state);
      return validators[key](value, state) && acc;
    }, true);
  };
  var isFormValidAsync = function isFormValidAsync(validatorsAsync) {
    return Object.keys(validatorsAsync).filter(function (key) {
      return validatorsAsync[key].type === "field";
    }).every(function (key) {
      var _validatorsAsync$key = validatorsAsync[key],
          counter = _validatorsAsync$key.counter,
          isValid = _validatorsAsync$key.isValid;
      return counter === 1 && isValid;
    });
  };
  var generateAsynFuncs = function generateAsynFuncs(validators, validatorsMaps, state, updateValidatorsMap) {
    return Object.keys(validators).filter(function (key) {
      var _validatorsMaps$key = validatorsMaps[key],
          type = _validatorsMaps$key.type,
          isValid = _validatorsMaps$key.isValid,
          counter = _validatorsMaps$key.counter;
      return counter === 0 && !isValid && type === "field" || type === "collection";
    }).map(function (key) {
      var value = getValueByPath(key, state);
      return validators[key](value, state).then(function (value) {
        updateValidatorsMap(key, true, 1);
        return value;
      })["catch"](function (err) {
        updateValidatorsMap(key, false, 1);
        throw err;
      });
    });
  };
  var shouldRunAsyncValidator = function shouldRunAsyncValidator(validatorsMaps) {
    return Object.keys(validatorsMaps).filter(function (key) {
      return validatorsMaps[key].type === "field";
    }).every(function (key) {
      var _validatorsMaps$key2 = validatorsMaps[key],
          isValid = _validatorsMaps$key2.isValid,
          counter = _validatorsMaps$key2.counter;
      return counter === 0 && !isValid || counter === 1 && isValid;
    });
  };
  var flatAsyncValidationMap = function flatAsyncValidationMap(asyncInitMap) {
    return Object.keys(asyncInitMap).reduce(function (acc, key) {
      var target = asyncInitMap[key];

      if (typeof target === "function") {
        acc.push(target());
      } else {
        var funcs = flatAsyncValidationMap(target);
        acc.push.apply(acc, _toConsumableArray(funcs));
      }

      return acc;
    }, []);
  };
  var fileList = function fileList(files) {
    var fileList = [];

    for (var i = 0, numFiles = files.length; i < numFiles; i++) {
      fileList.push(files[i]);
    }

    return fileList;
  };

  var emptyStateValue = {};
  var validatorsDefault = [];
  function useForm(_ref) {
    var initialState = _ref.initialState,
        touched = _ref.touched,
        _ref$onChange = _ref.onChange,
        onChange = _ref$onChange === void 0 ? noop : _ref$onChange,
        _ref$onReset = _ref.onReset,
        onReset = _ref$onReset === void 0 ? noop : _ref$onReset,
        _ref$onInit = _ref.onInit,
        onInit = _ref$onInit === void 0 ? noop : _ref$onInit,
        _ref$onSubmit = _ref.onSubmit,
        onSubmit = _ref$onSubmit === void 0 ? noop : _ref$onSubmit,
        _ref$onValidation = _ref.onValidation,
        onValidation = _ref$onValidation === void 0 ? noop : _ref$onValidation,
        _ref$resetSyncErr = _ref.resetSyncErr,
        resetSyncErr = _ref$resetSyncErr === void 0 ? noop : _ref$resetSyncErr,
        _ref$validators = _ref.validators,
        validatorsFuncs = _ref$validators === void 0 ? validatorsDefault : _ref$validators,
        _ref$resetAsyncErr = _ref.resetAsyncErr,
        resetAsyncErr = _ref$resetAsyncErr === void 0 ? noop : _ref$resetAsyncErr,
        asyncValidator = _ref.asyncValidator,
        _ref$onAsyncValidatio = _ref.onAsyncValidation,
        onAsyncValidation = _ref$onAsyncValidatio === void 0 ? noop : _ref$onAsyncValidatio,
        reducers = _ref.reducers,
        _getInitilaStateForm_ = _ref._getInitilaStateForm_,
        _onMultipleForm_ = _ref._onMultipleForm_,
        name = _ref.name,
        action = _ref.action;

    var _useState = React.useState(function () {
      return createForm(initialState);
    }),
        _useState2 = _slicedToArray(_useState, 2),
        formState = _useState2[0],
        dispatch = _useState2[1];

    var stateRef = React.useRef(formState);

    var _useRef = React.useRef(isUsingMultipleForm(_getInitilaStateForm_, _onMultipleForm_, name)),
        isMultipleForm = _useRef.current;

    var dispatchFormState = React.useCallback(function (_ref2) {
      var state = _ref2.state,
          status = _ref2.status,
          rest = _objectWithoutProperties(_ref2, ["state", "status"]);

      var prevState = status === STATUS.ON_RESET ? memoInitialState.current.state : status === STATUS.ON_INIT ? emptyStateValue : stateRef.current.state;
      var newState = status === STATUS.READY || status === STATUS.ON_SUBMIT ? state : applyReducers(state, prevState, prevState);
      stateRef.current = _objectSpread2(_objectSpread2({}, rest), {}, {
        status: status,
        state: newState
      });
      dispatch(stateRef.current);
    }, []);
    var memoInitialState = React.useRef(_objectSpread2({}, formState));
    var isMounted = React.useRef(false);
    var stillMounted = React.useCallback(function () {
      return isMounted.current;
    }, []);

    var _useValidators = useValidators(undefined, undefined, isMounted),
        _useValidators2 = _slicedToArray(_useValidators, 3),
        validators = _useValidators2[0],
        addValidators = _useValidators2[1],
        removeValidators = _useValidators2[2];

    var _useValidationFunctio = useValidationFunction(validatorsFuncs),
        validationMsg = _useValidationFunctio.validationMsg,
        validationObj = _useValidationFunctio.validationObj,
        validationFN = _useValidationFunctio.validationFN;

    var _useValidationFunctio2 = useValidationFunctionAsync(asyncValidator, onAsyncValidation),
        _useValidationFunctio3 = _slicedToArray(_useValidationFunctio2, 1),
        validationFNAsync = _useValidationFunctio3[0];

    var _useValidators3 = useValidators(undefined, undefined, isMounted, true),
        _useValidators4 = _slicedToArray(_useValidators3, 6),
        validatorsAsync = _useValidators4[0],
        addValidatorsAsync = _useValidators4[1],
        removeValidatorsAsync = _useValidators4[2],
        validatorsMapsAsync = _useValidators4[3],
        updateValidatorsMap = _useValidators4[4],
        resetValidatorsMap = _useValidators4[5];

    var applyReducers = React.useMemo(function () {
      return chainReducers(reducers);
    }, []);

    var _useMapFields = useMapFields(),
        unRegisterField = _useMapFields.unRegisterField,
        mapFields = _useMapFields.mapFields,
        updateRegisteredField = _useMapFields.updateRegisteredField;

    var changeProp = React.useCallback(function (nameProp, value) {
      var removeMe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var newState = updateState(stateRef.current.state, {
        value: value,
        nameProp: nameProp,
        removeMe: removeMe
      });
      propagateState(newState, false);
    }, []);
    var initProp = React.useCallback(function (nameProp, value, initialValue) {
      if (isMounted.current) {
        // we must update the memoInitialState with the new prop if form is mounted
        memoInitialState.current.state = updateState(memoInitialState.current.state, {
          isValid: initialValue,
          nameProp: nameProp
        });
        var newState = updateState(stateRef.current.state, {
          value: value,
          nameProp: nameProp
        });
        propagateState(newState, false);
      } else {
        var newStateInitial = updateState(memoInitialState.current.state, {
          value: initialValue,
          nameProp: nameProp
        });

        var _newState = updateState(stateRef.current.state, {
          value: value,
          nameProp: nameProp
        });

        memoInitialState.current.state = newStateInitial;
        stateRef.current.state = _newState;
      }
    }, []);
    var removeProp = React.useCallback(function (namePropExt, _ref3) {
      var currentState = _ref3.currentState,
          removeCurrent = _ref3.removeCurrent,
          initialState = _ref3.initialState,
          removeInitial = _ref3.removeInitial;
      var newState = updateState(stateRef.current.state, {
        value: currentState,
        nameProp: namePropExt,
        removeMe: removeCurrent
      }); // if a prop removed was also a prop already initialized we must update the memoInitialState

      memoInitialState.current.state = updateState(memoInitialState.current.state, {
        value: initialState,
        nameProp: namePropExt,
        removeMe: removeInitial
      });
      propagateState(newState);
    }, []);
    var propagateState = React.useCallback(function (state, changePristine) {
      var status = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STATUS.ON_CHANGE;
      var pristine = changePristine !== undefined ? changePristine : stateRef.current.pristine;
      var isValid = isFormValid(validators.current, state) && isFormValidAsync(validatorsMapsAsync.current);
      dispatchFormState(_objectSpread2(_objectSpread2({}, stateRef.current), {}, {
        state: state,
        isValid: isValid,
        pristine: pristine,
        status: status
      }));
    }, []);
    var resetObj = React.useRef({});
    var registerReset = React.useCallback(function (nameProp, fnReset) {
      resetObj.current = _objectSpread2(_objectSpread2({}, resetObj.current), {}, _defineProperty({}, nameProp, fnReset));
    }, []);
    var unRegisterReset = React.useCallback(function (nameProp) {
      delete resetObj.current[nameProp];
    }, []);
    var reset = React.useCallback(function () {
      var state = Object.keys(resetObj.current).reduce(function (acc, key) {
        var value = resetObj.current[key](memoInitialState.current.state);
        if (value !== undefined) acc[key] = value;
        return acc;
      }, {});
      var validatorsMapsAsync = resetValidatorsMap();
      var isValid = isFormValid(validators.current, state) && isFormValidAsync(validatorsMapsAsync);
      var status = STATUS.ON_RESET;
      dispatchFormState(_objectSpread2(_objectSpread2({}, memoInitialState.current), {}, {
        state: state,
        status: status,
        isValid: isValid
      }));
    }, []);
    var onSubmitForm = React.useCallback(function (e) {
      e.persist();
      var _stateRef$current = stateRef.current,
          isValid = _stateRef$current.isValid,
          prevAttempts = _stateRef$current.submitAttempts;
      var status = STATUS.ON_SUBMIT;

      if (typeof action !== "string" || !isValid) {
        e.preventDefault();
      }

      var submitAttempts = prevAttempts + 1;

      if (isValid && Object.keys(validatorsAsync.current).length > 0 && shouldRunAsyncValidator(validatorsMapsAsync.current)) {
        var state = stateRef.current.state;
        var asyncArrayProm = generateAsynFuncs(validatorsAsync.current, validatorsMapsAsync.current, state, updateValidatorsMap);
        var target = e.target;
        e.preventDefault(); // Set isValid to false until it ends the async checks

        dispatchFormState(_objectSpread2(_objectSpread2({}, stateRef.current), {}, {
          isValid: false,
          isSubmitting: true,
          submitAttempts: submitAttempts
        }));
        Promise.all(asyncArrayProm).then(function () {
          if (typeof action === "string") {
            target.submit();
          } else {
            dispatchFormState(_objectSpread2(_objectSpread2({}, stateRef.current), {}, {
              status: status,
              isValid: true
            }));
          }
        })["catch"](function () {
          var isValid = shouldRunAsyncValidator(validatorsMapsAsync.current);
          var isSubmitting = false;
          dispatchFormState(_objectSpread2(_objectSpread2({}, stateRef.current), {}, {
            isValid: isValid,
            isSubmitting: isSubmitting
          }));
        });
      } else {
        dispatchFormState(_objectSpread2(_objectSpread2({}, stateRef.current), {}, {
          status: status,
          isSubmitting: true,
          submitAttempts: submitAttempts
        }));
      }
    }, []); // used only to replace the entire Form State

    var dispatchNewState = React.useCallback(function (nextState) {
      var newState = nextState;

      if (typeof nextState === "function") {
        var currentState = stateRef.current.state;
        newState = nextState(currentState);
      }

      propagateState(newState, false);
    }, []);
    var isFormTouchedOnce = React.useRef(false);
    var lastStateSyncCheck = React.useRef(null);
    var triggerSyncValidation = React.useCallback(function (omitArg1, omitArg2) {
      var touchedEventField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (lastStateSyncCheck.current !== stateRef.current.state && validationObj.current !== null && (isFormTouchedOnce.current || touched && touchedEventField || !touched)) {
        isFormTouchedOnce.current = true;
        lastStateSyncCheck.current = stateRef.current.state;
        var _validationObj$curren = validationObj.current,
            isValid = _validationObj$curren.isValid,
            checks = _validationObj$curren.checks;
        onValidation(checks, isValid);
      }
    }, []); // used to register async validation Actions

    var asyncInitValidation = React.useRef({});
    var registerAsyncInitValidation = React.useCallback(function (nameProp, asyncFunc) {
      asyncInitValidation.current[nameProp] = asyncFunc;
    }, []);
    var runInitialAsyncValidators = React.useCallback(function () {
      var keyAsyncValitions = Object.keys(asyncInitValidation.current);

      if (keyAsyncValitions.length > 0) {
        var status = STATUS.ON_INIT_ASYNC;
        dispatchFormState(_objectSpread2(_objectSpread2({}, stateRef.current), {}, {
          status: status
        }));
        var promises = flatAsyncValidationMap(asyncInitValidation.current);
        Promise.all(promises).then(function () {
          var status = STATUS.READY;
          var isValid = isFormValid(validators.current, stateRef.current.state);
          dispatchFormState(_objectSpread2(_objectSpread2({}, stateRef.current), {}, {
            status: status,
            isValid: isValid
          }));
        })["catch"](function () {
          var status = STATUS.READY;
          var isValid = false;
          dispatchFormState(_objectSpread2(_objectSpread2({}, stateRef.current), {}, {
            status: status,
            isValid: isValid
          }));
        });
      }
    }, []);
    var runAsyncValidation = React.useCallback(function (_ref4) {
      var start = _ref4.start,
          end = _ref4.end;

      if (start) {
        var status = STATUS.ON_RUN_ASYNC;
        dispatchFormState(_objectSpread2(_objectSpread2({}, stateRef.current), {}, {
          isValid: false,
          status: status
        }));
      } else if (end) {
        var _status = STATUS.ON_ASYNC_END;
        var isValid = isFormValid(validators.current, stateRef.current.state) && isFormValidAsync(validatorsMapsAsync.current);
        dispatchFormState(_objectSpread2(_objectSpread2({}, stateRef.current), {}, {
          isValid: isValid,
          status: _status
        }));
      }
    }, []); // change status form to READY after being reset

    React.useEffect(function () {
      var _stateRef$current2 = stateRef.current,
          status = _stateRef$current2.status,
          state = _stateRef$current2.state,
          isValid = _stateRef$current2.isValid;

      if (status === STATUS.ON_RESET) {
        onReset(state, isValid);
        dispatchFormState(_objectSpread2(_objectSpread2({}, stateRef.current), {}, {
          status: STATUS.RESETTED
        }));
      } else if (status === STATUS.ON_CHANGE) {
        onChange(state, isValid);
      } else if (status === STATUS.ON_INIT) {
        runInitialAsyncValidators();
        onInit(state, isValid);
      } else if (status === STATUS.ON_SUBMIT) {
        var common = {
          isSubmitting: false,
          status: STATUS.READY
        };

        if (isValid) {
          var result = onSubmit(state, isValid);

          if (result && typeof result.then === "function") {
            result.then(function () {
              var submitted = stateRef.current.submitted + 1;
              dispatchFormState(_objectSpread2(_objectSpread2(_objectSpread2({}, stateRef.current), common), {}, {
                submitted: submitted
              }));
            })["catch"](function () {
              return dispatchFormState(_objectSpread2(_objectSpread2({}, stateRef.current), common));
            });
          } else {
            var prevSub = stateRef.current.submitted;
            var submitted = result === false ? prevSub : prevSub + 1;
            dispatchFormState(_objectSpread2(_objectSpread2(_objectSpread2({}, stateRef.current), common), {}, {
              submitted: submitted
            }));
          }
        } else {
          dispatchFormState(_objectSpread2(_objectSpread2({}, stateRef.current), common));
        }
      }

      if (isMultipleForm && (status === STATUS.ON_RESET || status === STATUS.ON_CHANGE || status === STATUS.ON_INIT || status === STATUS.ON_SUBMIT)) {
        _onMultipleForm_(name, state);
      }
    }, [stateRef.current]); // after form is mounted dispatch the initial state

    React.useEffect(function () {
      isMounted.current = true; // Add its own validators

      if (validatorsFuncs.length > 0) {
        addValidators(FORM_VALIDATION_LABEL, validationFN.current);
      } // Add its own async validator func


      if (typeof asyncValidator === "function") {
        addValidatorsAsync(FORM_VALIDATION_LABEL, validationFNAsync.current, null);
      }

      var pristine = isMultipleForm && (_getInitilaStateForm_(name) == undefined || Object.keys(_getInitilaStateForm_(name)).length === 0) || !isMultipleForm;
      var state = isMultipleForm ? _getInitilaStateForm_(name) || stateRef.current.state : stateRef.current.state;
      var isValid = isFormValid(validators.current, state) && isFormValidAsync(validatorsMapsAsync.current);
      stateRef.current = _objectSpread2(_objectSpread2({}, stateRef.current), {}, {
        state: state,
        isValid: isValid,
        pristine: pristine,
        status: STATUS.ON_INIT
      });
      dispatchFormState(stateRef.current);
    }, []);
    React.useEffect(function () {
      var formStatus = formState.status;

      if (formStatus === STATUS.ON_RESET) {
        isFormTouchedOnce.current = false;
        lastStateSyncCheck.current = false;
        resetSyncErr();
        resetAsyncErr();
      } else if (formStatus !== STATUS.READY && formStatus !== STATUS.ON_INIT_ASYNC) {
        if (validationObj.current !== null) {
          triggerSyncValidation(false, true, false);
        }

        if (validationObj.current !== null && !validationObj.current.isValid) {
          resetAsyncErr();
        }
      }
    }, [validationMsg.current, formState.status]);
    return _objectSpread2(_objectSpread2({}, formState), {}, {
      // { isValid, state, status, pristine, isSubmitting }
      formState: formState.state,
      // pass the global form state down
      formStatus: formState.status,
      // pass the global form status down
      mapFields: mapFields.current,
      triggerSyncValidation: triggerSyncValidation,
      unRegisterField: unRegisterField,
      updateRegisteredField: updateRegisteredField,
      registerAsyncInitValidation: registerAsyncInitValidation,
      runAsyncValidation: runAsyncValidation,
      dispatchNewState: dispatchNewState,
      changeProp: changeProp,
      initProp: initProp,
      onSubmitForm: onSubmitForm,
      removeProp: removeProp,
      stillMounted: stillMounted,
      reset: reset,
      addValidators: addValidators,
      removeValidators: removeValidators,
      addValidatorsAsync: addValidatorsAsync,
      removeValidatorsAsync: removeValidatorsAsync,
      updateValidatorsMap: updateValidatorsMap,
      registerReset: registerReset,
      unRegisterReset: unRegisterReset
    });
  }

  function isUsingMultipleForm(_getInitilaStateForm_, _onMultipleForm_, name) {
    return typeof _getInitilaStateForm_ === "function" && typeof _onMultipleForm_ === "function" && typeof name === "string";
  }

  var ContextObject = /*#__PURE__*/React.createContext();
  var ContextForm = /*#__PURE__*/React.createContext();
  var usePublicContextForm = function usePublicContextForm() {
    var _useContext = React.useContext(ContextForm),
        state = _useContext.state,
        reset = _useContext.reset,
        isValid = _useContext.isValid,
        pristine = _useContext.pristine,
        submitted = _useContext.submitted,
        submitAttempts = _useContext.submitAttempts,
        isSubmitting = _useContext.isSubmitting,
        formStatus = _useContext.formStatus,
        dispatch = _useContext.dispatchNewState,
        onSubmitForm = _useContext.onSubmitForm;

    return {
      state: state,
      reset: reset,
      isValid: isValid,
      pristine: pristine,
      submitted: submitted,
      submitAttempts: submitAttempts,
      isSubmitting: isSubmitting,
      formStatus: formStatus,
      dispatch: dispatch,
      onSubmitForm: onSubmitForm
    };
  };
  function useOwnContext() {
    var contextObject = React.useContext(ContextObject);
    var contextForm = React.useContext(ContextForm);
    var context = contextObject || contextForm;
    return context;
  }

  function Form(_ref) {
    var children = _ref.children,
        initialState = _ref.initialState,
        onChange = _ref.onChange,
        onInit = _ref.onInit,
        onReset = _ref.onReset,
        onSubmit = _ref.onSubmit,
        onValidation = _ref.onValidation,
        resetSyncErr = _ref.resetSyncErr,
        validators = _ref.validators,
        asyncValidator = _ref.asyncValidator,
        onAsyncValidation = _ref.onAsyncValidation,
        resetAsyncErr = _ref.resetAsyncErr,
        reducers = _ref.reducers,
        touched = _ref.touched,
        _getInitilaStateForm_ = _ref._getInitilaStateForm_,
        _onMultipleForm_ = _ref._onMultipleForm_,
        name = _ref.name,
        action = _ref.action,
        innerRef = _ref.innerRef,
        rest = _objectWithoutProperties(_ref, ["children", "initialState", "onChange", "onInit", "onReset", "onSubmit", "onValidation", "resetSyncErr", "validators", "asyncValidator", "onAsyncValidation", "resetAsyncErr", "reducers", "touched", "_getInitilaStateForm_", "_onMultipleForm_", "name", "action", "innerRef"]);

    var _useForm = useForm({
      initialState: initialState,
      touched: touched,
      onChange: onChange,
      onInit: onInit,
      onReset: onReset,
      onSubmit: onSubmit,
      onValidation: onValidation,
      resetSyncErr: resetSyncErr,
      validators: validators,
      asyncValidator: asyncValidator,
      onAsyncValidation: onAsyncValidation,
      resetAsyncErr: resetAsyncErr,
      reducers: reducers,
      _getInitilaStateForm_: _getInitilaStateForm_,
      _onMultipleForm_: _onMultipleForm_,
      name: name,
      action: action
    }),
        onSubmitForm = _useForm.onSubmitForm,
        props = _objectWithoutProperties(_useForm, ["onSubmitForm"]);

    var ctx = React.useMemo(function () {
      return props;
    }, [props.state, props.isValid, props.status, props.pristine, props.isSubmitting, props.submitAttempts, props.submitted]);
    return /*#__PURE__*/React__default['default'].createElement(ContextForm.Provider, {
      value: ctx
    }, /*#__PURE__*/React__default['default'].createElement("form", _extends({
      action: action,
      onSubmit: onSubmitForm
    }, rest, {
      name: name,
      ref: innerRef
    }), children));
  }

  var Form$1 = /*#__PURE__*/React.memo(Form);

  var IndexContext = /*#__PURE__*/React.createContext();
  var ids = -1;
  function withIndex(Cmp) {
    var WithIndex = /*#__PURE__*/function (_PureComponent) {
      _inherits(WithIndex, _PureComponent);

      var _super = _createSuper(WithIndex);

      function WithIndex(props) {
        var _this;

        _classCallCheck(this, WithIndex);

        _this = _super.call(this, props);
        ids = ids + 1;
        _this.state = {
          id: ids,
          getID: _this.getID
        };
        return _this;
      }

      _createClass(WithIndex, [{
        key: "getID",
        value: function getID() {
          return ++ids;
        }
      }, {
        key: "render",
        value: function render() {
          return /*#__PURE__*/React__default['default'].createElement(IndexContext.Provider, {
            value: this.state
          }, /*#__PURE__*/React__default['default'].createElement(Cmp, this.props));
        }
      }]);

      return WithIndex;
    }(React.PureComponent);

    return WithIndex;
  }

  var useNameProp = function useNameProp(context, name, index) {
    var nameProp = React.useRef(name);
    var uniqueIDFromContext = React.useContext(IndexContext);
    var uniqueIDarrayContext = uniqueIDFromContext !== undefined ? uniqueIDFromContext.id : 1;
    var setNameProp = React.useCallback(function (index) {
      nameProp.current = index;
    }, []);

    if (context.type === "array") {
      if (index !== undefined) {
        uniqueIDarrayContext = uniqueIDFromContext.getID();
        nameProp.current = index;
      } else if (nameProp.current === undefined) {
        nameProp.current = context.getIndex(uniqueIDarrayContext);
      }
    }

    return {
      nameProp: nameProp,
      uniqueIDarrayContext: uniqueIDarrayContext,
      setNameProp: setNameProp
    };
  };

  function isValidValue(value, contextType) {
    if (contextType === "array") {
      return typeof value === "undefined";
    } else {
      return !(typeof value === "undefined" || typeof value === "number" && isNaN(value) || _typeof(value) === "object" || value === null || typeof value === "boolean");
    }
  }

  function isValidIndex(value) {
    var x = parseFloat(value);
    return !isNaN(value) && (x | 0) === x && x >= 0;
  }

  var validationPropsFuncs = [asyncValidatorProp, valueProp, nameProp, contextTypeProp, typeProp];
  function validateProps(target, props, contextType) {
    var errors = validationPropsFuncs.map(function (fn) {
      return fn(target, props, contextType);
    }).filter(Boolean);

    if (errors.length > 0) {
      throw new Error(errors[0]);
    }
  }

  function asyncValidatorProp(target, _ref) {
    var type = _ref.type,
        asyncValidator = _ref.asyncValidator;

    if (typeof asyncValidator !== "undefined" && typeof asyncValidator !== "function") {
      return "The prop \"asyncValidator\" -> \"".concat(asyncValidator, "\" passed to \"").concat(target, "\" of type: ").concat(type, " is not allowed. It must be a function");
    }
  }

  function valueProp(target, _ref2) {
    var type = _ref2.type,
        value = _ref2.value;

    if (typeof value !== "undefined" && (type === "array" && value.constructor !== Array || type === "object" && _typeof(value) !== "object")) {
      return "The prop \"value\": ".concat(value, " of type \"").concat(type, "\" passed to \"").concat(target, "\" it is not allowed as initial value.");
    }
  }

  function nameProp(target, _ref3, contextType) {
    var name = _ref3.name;

    if (!isValidValue(name, contextType)) {
      return "The prop \"name\": ".concat(name, " of type \"").concat(_typeof(name), "\" passed to \"").concat(target, "\" it is not allowed within context a of type \"").concat(contextType, "\".");
    }
  }

  function contextTypeProp(target, _ref4, contextType) {
    var type = _ref4.type,
        index = _ref4.index;

    if (contextType === "array" && !isValidIndex(index)) {
      return "The prop \"index\": ".concat(index, " of type \"").concat(_typeof(index), "\" passed to a ").concat(target, " \"").concat(type, "\" must be either a string or number represent as integers.");
    }
  }

  function typeProp(target, _ref5) {
    var name = _ref5.name,
        value = _ref5.value,
        checked = _ref5.checked,
        type = _ref5.type;

    if (typeof type === "undefined") {
      return "The prop \"type\" -> \"".concat(type, "\"\" passed to \"").concat(target, "\" is not allowed. It must be a string.");
    }

    if (type === "file" && value && value !== "") {
      return "The prop \"value\" -> \"".concat(value, "\" passed to \"").concat(target, "\": ").concat(name, " of type: ").concat(type, " is not allowed. Input of type \"file\" does not support any default value.");
    }

    if (type === "radio" && (value === undefined || typeof value === "string" && value.replace(/ /g, "") === "")) {
      return "".concat(target, " of type => ").concat(type, ", must have a valid prop \"value\".");
    }

    if (type !== "checkbox" && type !== "radio" && checked) {
      return "The prop \"checked\" -> \"".concat(checked, "\" passed to \"").concat(target, "\": ").concat(name, " of type: ").concat(type, " is not allowed. You can use \"value\" prop instead to set an initial value.");
    }
  }

  var validatorsDefault$1 = [];
  function useField(props) {
    var context = useOwnContext();
    var name = props.name,
        index = props.index,
        _props$validators = props.validators,
        validators = _props$validators === void 0 ? validatorsDefault$1 : _props$validators,
        asyncValidator = props.asyncValidator,
        type = props.type,
        _props$onFocus = props.onFocus,
        customFocus = _props$onFocus === void 0 ? noop : _props$onFocus,
        _props$onBlur = props.onBlur,
        customBlur = _props$onBlur === void 0 ? noop : _props$onBlur,
        _props$onChange = props.onChange,
        customChange = _props$onChange === void 0 ? noop : _props$onChange,
        _props$onValidation = props.onValidation,
        onValidation = _props$onValidation === void 0 ? noop : _props$onValidation,
        _props$resetSyncErr = props.resetSyncErr,
        resetSyncErr = _props$resetSyncErr === void 0 ? noop : _props$resetSyncErr,
        _props$resetAsyncErr = props.resetAsyncErr,
        resetAsyncErr = _props$resetAsyncErr === void 0 ? noop : _props$resetAsyncErr,
        onAsyncValidation = props.onAsyncValidation,
        _props$value = props.value,
        initialValue = _props$value === void 0 ? "" : _props$value,
        _props$checked = props.checked,
        initialChecked = _props$checked === void 0 ? false : _props$checked,
        _props$touched = props.touched,
        touched = _props$touched === void 0 ? false : _props$touched,
        _props$multiple = props.multiple,
        multiple = _props$multiple === void 0 ? false : _props$multiple,
        reducers = props.reducers;

    var _useNameProp = useNameProp(context, name, index),
        nameProp = _useNameProp.nameProp,
        uniqueIDarrayContext = _useNameProp.uniqueIDarrayContext,
        setNameProp = _useNameProp.setNameProp;

    {
      validateProps("<Input />", _objectSpread2(_objectSpread2({}, props), {}, {
        index: nameProp.current
      }), context.type);
    }

    var state = context.state;
    var formState = React.useRef(null);
    formState.current = context.formState;
    var isMounted = React.useRef(false);
    var valueField = React.useRef(initialValue);
    var checkedField = React.useRef(initialChecked);
    var fileField = React.useRef("");
    var valueFieldLastAsyncCheck = React.useRef(null);
    var valueFieldLastSyncCheck = React.useRef(null);

    var _getInitialValue = getInitialValue(type, state, nameProp, initialValue, initialChecked, isMounted, context),
        _getInitialValue2 = _slicedToArray(_getInitialValue, 2),
        initialValueRef = _getInitialValue2[0],
        initialCheckedRef = _getInitialValue2[1];

    if (!isMounted.current && initialValueRef.current) {
      valueField.current = initialValueRef.current;
    } else {
      if (type === "checkbox" || type === "radio") {
        valueField.current = initialValueRef.current;
        checkedField.current = type === "checkbox" ? state[nameProp.current] !== undefined || !isMounted.current && initialChecked === true : state[nameProp.current] === initialValueRef.current;
      } else if (type === "select") {
        valueField.current = state[nameProp.current] !== undefined ? state[nameProp.current] : !multiple ? "" : [];
      } else if (type === "file") {
        valueField.current = state[nameProp.current];
        fileField.current = state[nameProp.current] !== undefined ? fileField.current : "";
      } else if (type === "custom") {
        valueField.current = state[nameProp.current];
      } else {
        valueField.current = state[nameProp.current] !== undefined ? state[nameProp.current] : "";
      }
    }

    var applyReducers = React.useMemo(function () {
      return chainReducers(reducers);
    }, []);
    var reset = React.useCallback(function (formState) {
      valueFieldLastAsyncCheck.current = null;
      valueFieldLastSyncCheck.current = null;

      switch (type) {
        case "number":
        case "range":
          {
            var val = initialValueRef.current !== "" ? Number(initialValueRef.current) : initialValueRef.current;
            var value = applyReducers(val, valueField.current, formState);
            return value === "" ? undefined : value;
          }

        case "radio":
        case "checkbox":
          {
            checkedField.current = initialCheckedRef.current;
            var _val = initialValueRef.current;

            var _value = applyReducers(_val, valueField.current, formState);

            return initialCheckedRef.current === false ? undefined : _value;
          }

        default:
          {
            var _val2 = initialValueRef.current;

            var _value2 = applyReducers(_val2, valueField.current, formState);

            return _value2 === "" ? undefined : _value2;
          }
      }
    }, []);
    var updateValue = React.useCallback(function (nextValue, event) {
      var newValue = applyReducers(nextValue, valueField.current, formState.current);
      customChange(newValue, event);
      context.changeProp(nameProp.current, newValue, false);
    }, []);
    var onChange = React.useCallback(function (event) {
      if (typeof event.persist === "function") {
        event.persist();
      }

      var target = event.target;
      var nextValue;

      if (type === "select" && multiple) {
        var options = target.options;
        nextValue = [];

        for (var i = 0, l = options.length; i < l; i++) {
          if (options[i].selected) {
            nextValue.push(options[i].value);
          }
        }
      } else if (type === "file") {
        nextValue = multiple ? fileList(target.files) : target.files[0];
        fileField.current = target.value;
      } else if (type === "checkbox") {
        nextValue = checkedField.current === true ? "" : initialValueRef.current || target.value || true;
      } else if (type === "radio") {
        nextValue = initialValueRef.current || target.value || true;
      } else if (type === "number" || type === "range") {
        nextValue = target.value !== "" ? Number(target.value) : target.value;
      } else {
        nextValue = target.value;
      }

      updateValue(nextValue, event);
    }, []);
    var setValue = React.useCallback(function (resolveNextState) {
      var nextValue = typeof resolveNextState === "function" ? resolveNextState(valueField.current) : resolveNextState;
      updateValue(nextValue);
    }, []);
    /* it runs once and set the inital `value` if passed
      and registers the validators functions if there is any
    */

    React.useEffect(function () {
      isMounted.current = true;

      if (context.type === "array") {
        context.registerIndex(uniqueIDarrayContext, setNameProp);
      }

      if (validators.length > 0) {
        context.addValidators(nameProp.current, validationFN.current);
      } // register field for the useSelector


      context.updateRegisteredField(nameProp.current, setValue); // Adding asyncValidator function and mapping its value as false

      if (typeof asyncValidator === "function") {
        context.addValidatorsAsync(nameProp.current, validationFNAsync.current, false);

        if (initialValue !== "" || initialValueRef.current !== "") {
          context.registerAsyncInitValidation(nameProp.current, function () {
            valueFieldLastAsyncCheck.current = initialValueRef.current;
            return validationFNAsync.current(initialValueRef.current).then(function () {
              context.updateValidatorsMap(nameProp.current, true, 1);
            })["catch"](function (err) {
              if (err !== "cancelled") {
                context.updateValidatorsMap(nameProp.current, false, 1);
              }

              throw err;
            });
          });
        }
      }

      if (type === "radio" && initialCheckedRef.current === true) {
        context.registerReset(nameProp.current, reset);
      }

      if (type !== "radio") {
        context.registerReset(nameProp.current, reset);
      }
      /* if a initialValue or initialChecked is passed as prop */


      if (type !== "checkbox" && type !== "radio" && initialValue !== "" || (type === "checkbox" || type === "radio") && initialChecked) {
        // a checkbox might have a value otherwise its value will be true
        var val = initialValue;

        if (type === "checkbox") {
          val = type === "checkbox" ? initialValue || true : initialValue;
        } else if (type === "number" || type === "range") {
          val = Number(val);
        }

        var newValue = applyReducers(val, initialValue, formState.current);
        context.initProp(nameProp.current, newValue, val);
      }

      return function () {
        resetSyncErr();
        resetAsyncErr();

        if (context.stillMounted()) {
          context.unRegisterField(nameProp.current);

          if (typeof asyncValidator === "function") {
            context.removeValidatorsAsync(nameProp.current, validationFNAsync.current);
          }

          if (validators.length > 0) {
            context.removeValidators(nameProp.current, validationFN.current);
          }

          context.removeProp(nameProp.current, {
            removeCurrent: true,
            removeInitial: true
          }, true);
          context.unRegisterReset(nameProp.current);

          if (context.type === "array") {
            context.removeIndex(uniqueIDarrayContext);
          }
        }
      };
    }, []);

    var _useValidationFunctio = useValidationFunction(validators),
        validationMsg = _useValidationFunctio.validationMsg,
        validationObj = _useValidationFunctio.validationObj,
        validationFN = _useValidationFunctio.validationFN;

    var _useValidationFunctio2 = useValidationFunctionAsync(asyncValidator, onAsyncValidation),
        _useValidationFunctio3 = _slicedToArray(_useValidationFunctio2, 1),
        validationFNAsync = _useValidationFunctio3[0];

    var _useState = React.useState(function () {
      return false;
    }),
        _useState2 = _slicedToArray(_useState, 2),
        onSyncBlurState = _useState2[0],
        setSyncOnBlur = _useState2[1];

    var _useState3 = React.useState(function () {
      return false;
    }),
        _useState4 = _slicedToArray(_useState3, 2),
        onSyncFocusState = _useState4[0],
        setSyncOnFocus = _useState4[1];

    var _useState5 = React.useState(function () {
      return false;
    }),
        _useState6 = _slicedToArray(_useState5, 2),
        onAsyncBlurState = _useState6[0],
        setAsyncOnBlur = _useState6[1];

    React.useEffect(function () {
      if (context.formStatus === STATUS.ON_RESET) {
        setSyncOnBlur(false);
        setAsyncOnBlur(false);
        setSyncOnFocus(false);
        resetSyncErr();
        resetAsyncErr();
      } else if (context.formStatus !== STATUS.READY && context.formStatus !== STATUS.ON_INIT_ASYNC) {
        var firstTimeCheck = valueFieldLastSyncCheck.current === null;
        var onlyShowOnSubmit = type === "radio" || type === "checkbox";
        var isCustomCmp = type === "custom";
        var forceOnBlur = type === "select" && multiple;

        if (valueFieldLastSyncCheck.current !== valueField.current && validationObj.current !== null && (!onlyShowOnSubmit && initialValue !== "" || isCustomCmp && touched && onSyncBlurState || context.formStatus === STATUS.ON_SUBMIT || !onlyShowOnSubmit && (touched && onSyncBlurState || !touched && forceOnBlur && (onSyncBlurState || firstTimeCheck) || !touched && !forceOnBlur) || onlyShowOnSubmit && onSyncFocusState)) {
          valueFieldLastSyncCheck.current = valueField.current;
          onValidation(validationObj.current.checks, validationObj.current.isValid);
        }

        if (onSyncBlurState) {
          var _context$triggerSyncV;

          context === null || context === void 0 ? void 0 : (_context$triggerSyncV = context.triggerSyncValidation) === null || _context$triggerSyncV === void 0 ? void 0 : _context$triggerSyncV.call(context);
        }

        if ((validationObj.current !== null && validationObj.current.isValid || validators.length === 0) && onAsyncBlurState && context.formStatus !== STATUS.ON_SUBMIT && context.formStatus !== STATUS.ON_INIT_ASYNC && typeof asyncValidator === "function") {
          if (valueFieldLastAsyncCheck.current !== valueField.current) {
            valueFieldLastAsyncCheck.current = valueField.current;
            context.runAsyncValidation({
              start: true
            });
            validationFNAsync.current(valueField.current).then(function () {
              context.updateValidatorsMap(nameProp.current, true, 1);
              context.runAsyncValidation({
                end: true
              });
            })["catch"](function (err) {
              if (err !== "cancelled") {
                context.updateValidatorsMap(nameProp.current, false, 1);
                context.runAsyncValidation({
                  end: true
                });
              }
            });
          }
        }
      }
    }, [validationMsg.current, onSyncBlurState, onAsyncBlurState, onSyncFocusState, context.formStatus]);
    var onBlur = React.useCallback(function (e) {
      e.persist();
      setAsyncOnBlur(true);
      setSyncOnBlur(true);
      customBlur(e);
    }, []);
    var onFocus = React.useCallback(function (e) {
      e.persist();
      setSyncOnBlur(false);
      setAsyncOnBlur(false);
      setSyncOnFocus(true);
      customFocus(e);
    }, []);
    var attributes = filterProps({
      onChange: onChange,
      onBlur: onBlur,
      onFocus: onFocus,
      checked: checkedField.current,
      value: valueField.current,
      fileValue: fileField.current,
      type: type,
      name: name,
      multiple: multiple,
      setValue: setValue
    });
    return attributes;
  }

  function filterProps(allProps) {
    switch (allProps.type) {
      case "file":
        {
          var omitVal = allProps.value,
              _omitSetVal = allProps.setValue,
              fileValue = allProps.fileValue,
              _props = _objectWithoutProperties(allProps, ["value", "setValue", "fileValue"]);

          return _objectSpread2(_objectSpread2({}, _props), {}, {
            value: fileValue
          });
        }

      case "select":
        {
          var omitType = allProps.type,
              _omitSetVal2 = allProps.setValue,
              _omitFileVal = allProps.fileValue,
              _props2 = _objectWithoutProperties(allProps, ["type", "setValue", "fileValue"]);

          return _props2;
        }

      case "custom":
        {
          var omitfileVal = allProps.fileValue,
              _props3 = _objectWithoutProperties(allProps, ["fileValue"]);

          return _props3;
        }

      default:
        var omitFileVal = allProps.fileValue,
            omitSetVal = allProps.setValue,
            props = _objectWithoutProperties(allProps, ["fileValue", "setValue"]);

        return props;
    }
  }

  function getInitialValue(type, state, nameProp, initialValue, initialChecked, isMounted, context) {
    var initValueRef = initialValue;
    var initCheckRef = initialChecked;

    if (state[nameProp.current] !== undefined && !isMounted.current && !context.stillMounted()) {
      if (type !== "radio" && initValueRef === "") {
        initValueRef = state[nameProp.current];
      }

      if (initialChecked === false && (type === "checkbox" || type === "radio" && state[nameProp.current] === initialValue)) {
        initCheckRef = true;
      }
    }

    var initialValueRef = React.useRef(initValueRef);
    var initialCheckedRef = React.useRef(initCheckRef);
    return [initialValueRef, initialCheckedRef];
  }

  var Input = withIndex(function Input(_ref) {
    var onFocus = _ref.onFocus,
        onBlur = _ref.onBlur,
        onChange = _ref.onChange,
        name = _ref.name,
        index = _ref.index,
        checked = _ref.checked,
        validators = _ref.validators,
        asyncValidator = _ref.asyncValidator,
        onValidation = _ref.onValidation,
        onAsyncValidation = _ref.onAsyncValidation,
        resetSyncErr = _ref.resetSyncErr,
        resetAsyncErr = _ref.resetAsyncErr,
        type = _ref.type,
        value = _ref.value,
        touched = _ref.touched,
        multiple = _ref.multiple,
        reducers = _ref.reducers,
        innerRef = _ref.innerRef,
        extraProps = _objectWithoutProperties(_ref, ["onFocus", "onBlur", "onChange", "name", "index", "checked", "validators", "asyncValidator", "onValidation", "onAsyncValidation", "resetSyncErr", "resetAsyncErr", "type", "value", "touched", "multiple", "reducers", "innerRef"]);

    var props = useField({
      onFocus: onFocus,
      onBlur: onBlur,
      onChange: onChange,
      type: type,
      name: name,
      index: index,
      checked: checked,
      value: value,
      validators: validators,
      asyncValidator: asyncValidator,
      onValidation: onValidation,
      onAsyncValidation: onAsyncValidation,
      reducers: reducers,
      resetSyncErr: resetSyncErr,
      resetAsyncErr: resetAsyncErr,
      touched: touched,
      multiple: multiple
    });
    return /*#__PURE__*/React__default['default'].createElement("input", _extends({}, extraProps, props, {
      ref: innerRef
    }));
  });

  var Select = withIndex(function Select(_ref) {
    var onFocus = _ref.onFocus,
        onBlur = _ref.onBlur,
        onChange = _ref.onChange,
        children = _ref.children,
        name = _ref.name,
        index = _ref.index,
        validators = _ref.validators,
        asyncValidator = _ref.asyncValidator,
        onValidation = _ref.onValidation,
        onAsyncValidation = _ref.onAsyncValidation,
        resetSyncErr = _ref.resetSyncErr,
        resetAsyncErr = _ref.resetAsyncErr,
        multiple = _ref.multiple,
        value = _ref.value,
        touched = _ref.touched,
        reducers = _ref.reducers,
        innerRef = _ref.innerRef,
        extraProps = _objectWithoutProperties(_ref, ["onFocus", "onBlur", "onChange", "children", "name", "index", "validators", "asyncValidator", "onValidation", "onAsyncValidation", "resetSyncErr", "resetAsyncErr", "multiple", "value", "touched", "reducers", "innerRef"]);

    var props = useField({
      onFocus: onFocus,
      onBlur: onBlur,
      onChange: onChange,
      type: "select",
      name: name,
      index: index,
      value: value,
      validators: validators,
      asyncValidator: asyncValidator,
      onValidation: onValidation,
      onAsyncValidation: onAsyncValidation,
      resetSyncErr: resetSyncErr,
      resetAsyncErr: resetAsyncErr,
      touched: touched,
      multiple: multiple,
      reducers: reducers
    });
    return /*#__PURE__*/React__default['default'].createElement("select", _extends({}, extraProps, props, {
      ref: innerRef
    }), children);
  });

  var TextArea = withIndex(function TextArea(_ref) {
    var onFocus = _ref.onFocus,
        onBlur = _ref.onBlur,
        onChange = _ref.onChange,
        name = _ref.name,
        index = _ref.index,
        validators = _ref.validators,
        asyncValidator = _ref.asyncValidator,
        onValidation = _ref.onValidation,
        onAsyncValidation = _ref.onAsyncValidation,
        resetSyncErr = _ref.resetSyncErr,
        resetAsyncErr = _ref.resetAsyncErr,
        value = _ref.value,
        touched = _ref.touched,
        reducers = _ref.reducers,
        innerRef = _ref.innerRef,
        extraProps = _objectWithoutProperties(_ref, ["onFocus", "onBlur", "onChange", "name", "index", "validators", "asyncValidator", "onValidation", "onAsyncValidation", "resetSyncErr", "resetAsyncErr", "value", "touched", "reducers", "innerRef"]);

    var props = useField({
      onFocus: onFocus,
      onBlur: onBlur,
      onChange: onChange,
      type: "text",
      name: name,
      index: index,
      value: value,
      validators: validators,
      asyncValidator: asyncValidator,
      onValidation: onValidation,
      onAsyncValidation: onAsyncValidation,
      resetSyncErr: resetSyncErr,
      resetAsyncErr: resetAsyncErr,
      touched: touched,
      reducers: reducers
    });
    return /*#__PURE__*/React__default['default'].createElement("textarea", _extends({}, extraProps, props, {
      ref: innerRef
    }));
  });

  var initArray = [];
  var initObject = {};
  var validatorsDefault$2 = [];
  function useObject(props) {
    var context = useOwnContext();
    var name = props.name,
        index = props.index,
        type = props.type,
        initValue = props.value,
        reducers = props.reducers,
        _props$validators = props.validators,
        validatorsFuncs = _props$validators === void 0 ? validatorsDefault$2 : _props$validators,
        _props$onValidation = props.onValidation,
        onValidation = _props$onValidation === void 0 ? noop : _props$onValidation,
        _props$resetSyncErr = props.resetSyncErr,
        resetSyncErr = _props$resetSyncErr === void 0 ? noop : _props$resetSyncErr,
        _props$resetAsyncErr = props.resetAsyncErr,
        resetAsyncErr = _props$resetAsyncErr === void 0 ? noop : _props$resetAsyncErr,
        asyncValidator = props.asyncValidator,
        _props$onAsyncValidat = props.onAsyncValidation,
        onAsyncValidation = _props$onAsyncValidat === void 0 ? noop : _props$onAsyncValidat,
        _props$touched = props.touched,
        touched = _props$touched === void 0 ? false : _props$touched;

    var _useNameProp = useNameProp(context, name, index),
        nameProp = _useNameProp.nameProp,
        uniqueIDarrayContext = _useNameProp.uniqueIDarrayContext,
        setNameProp = _useNameProp.setNameProp;

    {
      validateProps("<Collection /> ", _objectSpread2(_objectSpread2({}, props), {}, {
        index: nameProp.current
      }), context.type);
    }

    var _useMapFields = useMapFields(nameProp, context, type),
        unRegisterField = _useMapFields.unRegisterField,
        mapFields = _useMapFields.mapFields,
        updateRegisteredField = _useMapFields.updateRegisteredField;

    var applyReducers = React.useMemo(function () {
      return chainReducers(reducers);
    }, []);
    var isMounted = React.useRef(false);
    var stillMounted = React.useCallback(function () {
      return isMounted.current;
    }, []);
    var isArray = type && type === "array";
    var init = initValue || (isArray ? initArray : initObject);
    var state = React.useRef(init);
    var memoInitialState = React.useRef(init);
    var prevState = React.useRef(isArray ? initArray : initObject);
    var valueFieldLastSyncCheck = React.useRef(null); // getValue from parent context

    if (!isMounted.current) {
      state.current = initValue || context.state[nameProp.current] || init;
    } else {
      state.current = context.state[nameProp.current] || (isArray ? initArray : initObject);
    }

    var formState = React.useRef(null);
    formState.current = context.formState;
    var resetObj = React.useRef(isArray ? [] : {});
    var registerReset = React.useCallback(function (namePropExt, fnReset) {
      resetObj.current = isArray ? _toConsumableArray(resetObj.current) : _objectSpread2({}, resetObj.current);

      if (isArray && typeof resetObj.current[namePropExt] !== "undefined") {
        resetObj.current.splice(Number(namePropExt), 0, fnReset);
      } else {
        resetObj.current[namePropExt] = fnReset;
      }
    }, []);
    var unRegisterReset = React.useCallback(function (namePropExt) {
      if (resetObj.current.constructor === Array) {
        resetObj.current.splice(namePropExt, 1);
      } else {
        delete resetObj.current[namePropExt];
      }
    }, []);
    var reset = React.useCallback(function (formState) {
      valueFieldLastSyncCheck.current = null;
      var initAcc = isArray ? [] : {};
      var obj = Object.keys(resetObj.current).reduce(function (acc, key) {
        var value = resetObj.current[key](formState);
        if (value !== undefined) acc[key] = value;
        return acc;
      }, initAcc);
      var newValue = applyReducers(obj, memoInitialState.current, formState);
      newValue = newValue !== undefined && Object.keys(newValue).length > 0 ? newValue : undefined;
      return newValue;
    }, []);
    var updateParentProps = React.useCallback(function (nextState) {
      var newState = applyReducers(nextState, state.current, formState.current);
      var removeProp = Object.keys(newState).length === 0;
      context.changeProp(nameProp.current, newState, removeProp);
    }, []);
    var changeProp = React.useCallback(function (namePropExt, value, removeMe) {
      var nextState = updateState(state.current, {
        value: value,
        nameProp: namePropExt,
        removeMe: removeMe
      });
      updateParentProps(nextState);
    }, []);
    var initProp = React.useCallback(function (namePropExt, value, intialValue) {
      var add = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var newState = updateState(state.current, {
        value: value,
        nameProp: namePropExt,
        add: isMounted.current && add
      });
      memoInitialState.current = updateState(memoInitialState.current, {
        value: intialValue,
        nameProp: namePropExt,
        add: isMounted.current && add
      });
      var reducedState = applyReducers(newState, state.current, formState.current);
      prevState.current = newState;

      if (isMounted.current) {
        context.initProp(nameProp.current, reducedState, memoInitialState.current, false);
      } else {
        state.current = reducedState;
      }
    }, []);

    var _useRef = React.useRef(function (namePropExt, _ref) {
      var currentState = _ref.currentState,
          removeCurrent = _ref.removeCurrent,
          initialState = _ref.initialState,
          removeInitial = _ref.removeInitial;
      var willUnmount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var newStateCurrent = updateState(state.current, {
        value: currentState,
        nameProp: namePropExt,
        removeMe: removeCurrent
      });
      var newStateInitial = updateState(memoInitialState.current, {
        value: initialState,
        nameProp: namePropExt,
        removeMe: removeInitial
      });

      if (willUnmount && isArray) {
        newStateCurrent = newStateCurrent.filter(function (elm, index) {
          return index !== namePropExt;
        });
        newStateInitial = newStateInitial.filter(function (elm, index) {
          return index !== namePropExt;
        });
      }

      var reducedState = applyReducers(newStateCurrent, state.current, formState.current);
      state.current = reducedState;
      memoInitialState.current = newStateInitial;
      var removeCurrentProp = Object.keys(state.current).length === 0;
      var removeInitialProp = Object.keys(memoInitialState.current).length === 0;
      context.removeProp(nameProp.current, {
        currentState: state.current,
        removeCurrent: removeCurrentProp,
        initialState: memoInitialState.current,
        removeInitial: removeInitialProp
      });
    }),
        removeProp = _useRef.current;

    var setValue = React.useCallback(function (resolveNextState) {
      var nextState = typeof resolveNextState === "function" ? resolveNextState(state.current) : resolveNextState;
      updateParentProps(nextState);
    }, []);

    var _useValidators = useValidators(context, nameProp, isMounted),
        _useValidators2 = _slicedToArray(_useValidators, 3),
        validators = _useValidators2[0],
        addValidators = _useValidators2[1],
        removeValidators = _useValidators2[2];

    var _useValidators3 = useValidators(context, nameProp, isMounted, true),
        _useValidators4 = _slicedToArray(_useValidators3, 5),
        validatorsAsync = _useValidators4[0],
        addValidatorsAsync = _useValidators4[1],
        removeValidatorsAsync = _useValidators4[2],
        validatorsMapsAsync = _useValidators4[3],
        updateValidatorsMap = _useValidators4[4];

    var _useValidationFunctio = useValidationFunction(validatorsFuncs),
        validationMsg = _useValidationFunctio.validationMsg,
        validationObj = _useValidationFunctio.validationObj,
        validationFN = _useValidationFunctio.validationFN;

    var _useValidationFunctio2 = useValidationFunctionAsync(asyncValidator, onAsyncValidation),
        _useValidationFunctio3 = _slicedToArray(_useValidationFunctio2, 1),
        validationFNAsync = _useValidationFunctio3[0];

    var triggerSyncValidation = React.useCallback(function () {
      var propagate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var onSubmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (valueFieldLastSyncCheck.current !== state.current) {
        if (validationObj.current !== null && (touched || onSubmit)) {
          valueFieldLastSyncCheck.current = state.current;
          var _validationObj$curren = validationObj.current,
              isValid = _validationObj$curren.isValid,
              checks = _validationObj$curren.checks;
          onValidation(checks, isValid);
        }

        if (propagate) {
          var _context$triggerSyncV;

          context === null || context === void 0 ? void 0 : (_context$triggerSyncV = context.triggerSyncValidation) === null || _context$triggerSyncV === void 0 ? void 0 : _context$triggerSyncV.call(context);
        }
      }
    }, []);
    React.useEffect(function () {
      if (context.formStatus === STATUS.ON_RESET) {
        resetSyncErr();
        resetAsyncErr();
      } else if (context.formStatus !== STATUS.READY && context.formStatus !== STATUS.ON_INIT_ASYNC) {
        if (validationObj.current !== null && context.formStatus === STATUS.ON_SUBMIT) {
          triggerSyncValidation(false, true);
        }

        if (validationObj.current !== null && !validationObj.current.isValid) {
          resetAsyncErr();
        }
      }
    }, [validationMsg.current, context.formStatus]); // used to register async validation Actions

    var asyncInitValidation = React.useRef({});
    var registerAsyncInitValidation = React.useCallback(function (nameProp, asyncFunc) {
      asyncInitValidation.current[nameProp] = asyncFunc;
    }, []);
    React.useEffect(function () {
      isMounted.current = true;

      if (context.type === "array") {
        context.registerIndex(uniqueIDarrayContext, setNameProp);
      } // Add its own validators


      if (validatorsFuncs.length > 0) {
        context.addValidators(nameProp.current, validationFN.current);
      }

      if (typeof asyncValidator === "function") {
        context.addValidatorsAsync(nameProp.current, validationFNAsync.current, null);
      }

      mapFields.current[DISPATCHER_LABEL] = setValue;
      context.updateRegisteredField(nameProp.current, mapFields.current); // register to parent any initial async Validators to be run ON_INIT

      if (Object.keys(asyncInitValidation.current).length > 0) {
        context.registerAsyncInitValidation(nameProp.current, asyncInitValidation.current);
      } // --- Add its own validators --- //
      // Add its children validators


      if (Object.keys(validators.current).length > 0) {
        context.addValidators(nameProp.current, validators.current);
      }

      if (Object.keys(validatorsAsync.current).length > 0) {
        context.addValidatorsAsync(nameProp.current, validatorsAsync.current, validatorsMapsAsync.current);
      } // --- Add the its children validators --- //


      context.registerReset(nameProp.current, reset);
      var newState = applyReducers(state.current, prevState.current, formState.current);
      context.initProp(nameProp.current, newState, memoInitialState.current);
      return function () {
        resetSyncErr();
        resetAsyncErr();
        isMounted.current = false;

        if (context.stillMounted()) {
          context.unRegisterField(nameProp.current); // remove its own by validators

          if (typeof asyncValidator === "function") {
            context.removeValidatorsAsync(nameProp.current, validationFNAsync.current, false);
          }

          if (validatorsFuncs.length > 0) {
            context.removeValidators(nameProp.current, validationFN.current);
          } // ----- remove its own by validators ----- //
          // remove validators inerithed by children


          if (Object.keys(validators.current).length > 0) {
            context.removeValidators(nameProp.current, validators.current);
          }

          if (Object.keys(validatorsAsync.current).length > 0) {
            context.removeValidatorsAsync(nameProp.current, validatorsAsync.current, validatorsMapsAsync.current);
          } // ----- remove validators inerithed by children ----- //


          context.removeProp(nameProp.current, {
            removeCurrent: true,
            removeInitial: true
          }, true);
          context.unRegisterReset(nameProp.current);

          if (context.type === "array") {
            context.removeIndex(uniqueIDarrayContext);
          }
        }
      };
    }, []);
    var childrenIndexes = React.useRef({});
    var getIndex = React.useCallback(function (idCpm) {
      if (childrenIndexes.current[idCpm] === undefined) {
        childrenIndexes.current[idCpm] = null;
      }

      return Object.keys(childrenIndexes.current).length - 1;
    }, []);
    var removeIndex = React.useCallback(function (idCpm) {
      delete childrenIndexes.current[idCpm];
      Object.keys(childrenIndexes.current).forEach(function (idField, index) {
        return childrenIndexes.current[idField](index);
      });
    }, []);
    var registerIndex = React.useCallback(function (idCpm, fn) {
      childrenIndexes.current[idCpm] = fn;
    }, []);
    return {
      state: state.current,
      // pass the state of the current context down
      formState: context.formState,
      // pass the global form state down
      formStatus: context.formStatus,
      // pass the global form status down
      runAsyncValidation: context.runAsyncValidation,
      unRegisterField: unRegisterField,
      updateRegisteredField: updateRegisteredField,
      registerAsyncInitValidation: registerAsyncInitValidation,
      changeProp: changeProp,
      initProp: initProp,
      removeProp: removeProp,
      stillMounted: stillMounted,
      getIndex: getIndex,
      removeIndex: removeIndex,
      registerIndex: registerIndex,
      type: type,
      addValidators: addValidators,
      removeValidators: removeValidators,
      addValidatorsAsync: addValidatorsAsync,
      removeValidatorsAsync: removeValidatorsAsync,
      updateValidatorsMap: updateValidatorsMap,
      registerReset: registerReset,
      unRegisterReset: unRegisterReset,
      triggerSyncValidation: triggerSyncValidation
    };
  }

  var Collection = withIndex(function Collection(_ref) {
    var children = _ref.children,
        name = _ref.name,
        index = _ref.index,
        object = _ref.object,
        touched = _ref.touched,
        value = _ref.value,
        reducers = _ref.reducers,
        onValidation = _ref.onValidation,
        resetSyncErr = _ref.resetSyncErr,
        validators = _ref.validators,
        asyncValidator = _ref.asyncValidator,
        onAsyncValidation = _ref.onAsyncValidation,
        resetAsyncErr = _ref.resetAsyncErr;
    var type = object ? "object" : "array";
    var props = useObject({
      name: name,
      index: index,
      touched: touched,
      type: type,
      value: value,
      reducers: reducers,
      onValidation: onValidation,
      validators: validators,
      resetSyncErr: resetSyncErr,
      asyncValidator: asyncValidator,
      onAsyncValidation: onAsyncValidation,
      resetAsyncErr: resetAsyncErr
    });
    var ctx = React.useMemo(function () {
      return props;
    }, [props.state, props.formStatus]);
    return /*#__PURE__*/React__default['default'].createElement(ContextObject.Provider, {
      value: ctx
    }, children);
  });

  var FormContext = /*#__PURE__*/React.memo(function FormContext(_ref) {
    var children = _ref.children,
        initialState = _ref.initialState,
        onChange = _ref.onChange,
        onInit = _ref.onInit,
        onReset = _ref.onReset,
        onSubmit = _ref.onSubmit,
        onValidation = _ref.onValidation,
        resetSyncErr = _ref.resetSyncErr,
        validators = _ref.validators,
        asyncValidator = _ref.asyncValidator,
        onAsyncValidation = _ref.onAsyncValidation,
        resetAsyncErr = _ref.resetAsyncErr,
        touched = _ref.touched,
        reducers = _ref.reducers,
        _getInitilaStateForm_ = _ref._getInitilaStateForm_,
        _onMultipleForm_ = _ref._onMultipleForm_,
        name = _ref.name,
        action = _ref.action;
    var props = useForm({
      initialState: initialState,
      onChange: onChange,
      onInit: onInit,
      onReset: onReset,
      onSubmit: onSubmit,
      onValidation: onValidation,
      resetSyncErr: resetSyncErr,
      validators: validators,
      asyncValidator: asyncValidator,
      onAsyncValidation: onAsyncValidation,
      resetAsyncErr: resetAsyncErr,
      touched: touched,
      reducers: reducers,
      _getInitilaStateForm_: _getInitilaStateForm_,
      _onMultipleForm_: _onMultipleForm_,
      name: name,
      action: action
    });
    var ctx = React.useMemo(function () {
      return props;
    }, [props.state, props.isValid, props.status, props.pristine, props.isSubmitting, props.submitAttempts, props.submitted]);
    return /*#__PURE__*/React__default['default'].createElement(ContextForm.Provider, {
      value: ctx
    }, children);
  });

  var initialState = {
    error: undefined,
    isValid: true
  };
  function useValidation() {
    var validators = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var _useState = React.useState(function () {
      return _objectSpread2({}, initialState);
    }),
        _useState2 = _slicedToArray(_useState, 2),
        status = _useState2[0],
        setState = _useState2[1];

    var onValidation = function onValidation(errors, isValid) {
      return setState({
        error: getValidationMsg(errors),
        isValid: isValid
      });
    };

    var resetSyncErr = function resetSyncErr() {
      return setState(_objectSpread2({}, initialState));
    };

    return [status, {
      onValidation: onValidation,
      validators: validators,
      resetSyncErr: resetSyncErr
    }];
  }

  function useSelector(fn) {
    var _useContext = React.useContext(ContextForm),
        state = _useContext.state,
        mapFields = _useContext.mapFields;

    var value;

    try {
      value = fn(state);
    } catch (_unused) {
      value = undefined;
    }

    var setFieldValue;

    try {
      var fieldDispatcher = fn(mapFields);
      setFieldValue = (fieldDispatcher === null || fieldDispatcher === void 0 ? void 0 : fieldDispatcher[DISPATCHER_LABEL]) || fieldDispatcher;
    } catch (_unused2) {
      setFieldValue = undefined;
    }

    return [value, setFieldValue];
  }

  var initialStatus = {
    status: undefined,
    value: undefined
  };
  function useAsyncValidation(asyncValidator) {
    var _useState = React.useState(function () {
      return _objectSpread2({}, initialStatus);
    }),
        _useState2 = _slicedToArray(_useState, 2),
        status = _useState2[0],
        setStatus = _useState2[1];

    var onAsyncValidation = function onAsyncValidation(newStatus) {
      return setStatus(_objectSpread2(_objectSpread2({}, status), newStatus));
    };

    var resetAsyncErr = function resetAsyncErr() {
      return setStatus(_objectSpread2({}, initialStatus));
    };

    return [status, {
      onAsyncValidation: onAsyncValidation,
      asyncValidator: asyncValidator,
      resetAsyncErr: resetAsyncErr
    }];
  }

  function useChildren() {
    var initialState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var onReset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

    var _useState = React.useState(function () {
      return initialState;
    }),
        _useState2 = _slicedToArray(_useState, 2),
        children = _useState2[0],
        setChilren = _useState2[1];

    var _usePublicContextForm = usePublicContextForm(),
        formStatus = _usePublicContextForm.formStatus;

    React.useEffect(function () {
      if (formStatus === STATUS.ON_RESET) {
        setChilren([]);
        onReset();
      }
    }, [formStatus]);
    return [children, setChilren];
  }

  function useCollection(_ref) {
    var name = _ref.name,
        index = _ref.index,
        type = _ref.type,
        initialValue = _ref.value,
        reducers = _ref.reducers,
        onValidation = _ref.onValidation,
        resetSyncErr = _ref.resetSyncErr,
        validators = _ref.validators,
        asyncValidator = _ref.asyncValidator,
        onAsyncValidation = _ref.onAsyncValidation,
        resetAsyncErr = _ref.resetAsyncErr;

    var _useObject = useObject({
      name: name,
      index: index,
      type: type,
      value: initialValue,
      reducers: reducers,
      onValidation: onValidation,
      validators: validators,
      resetSyncErr: resetSyncErr,
      asyncValidator: asyncValidator,
      onAsyncValidation: onAsyncValidation,
      resetAsyncErr: resetAsyncErr
    }),
        changeProp = _useObject.changeProp,
        value = _useObject.state,
        state = _useObject.formState;

    var updateCollection = React.useCallback(function (propName, value) {
      return changeProp(propName, value);
    }, []);
    return {
      updateCollection: updateCollection,
      value: value,
      state: state
    };
  }

  function useMultipleForm(onChange) {
    var stateRef = React.useRef({}); // private API

    var _useRef = React.useRef(function (formName, state) {
      stateRef.current[formName] = state;

      if (typeof onChange === "function") {
        onChange(mergeFormStates(stateRef.current));
      }
    }),
        _onMultipleForm_ = _useRef.current; // private API


    var _useRef2 = React.useRef(function (formName) {
      return stateRef.current[formName];
    }),
        _getInitilaStateForm_ = _useRef2.current;

    var _useRef3 = React.useRef(function () {
      return mergeFormStates(stateRef.current);
    }),
        getState = _useRef3.current;

    return [getState, {
      _getInitilaStateForm_: _getInitilaStateForm_,
      _onMultipleForm_: _onMultipleForm_
    }];
  }

  function mergeFormStates(formStates) {
    return Object.keys(formStates).reduce(function (acc, key) {
      return _objectSpread2(_objectSpread2({}, acc), formStates[key]);
    }, {});
  }

  exports.Collection = Collection;
  exports.Form = Form$1;
  exports.FormContext = FormContext;
  exports.Input = Input;
  exports.STATUS = STATUS;
  exports.Select = Select;
  exports.TextArea = TextArea;
  exports.default = Form$1;
  exports.getValueByPath = getValueByPath;
  exports.useAsyncValidation = useAsyncValidation;
  exports.useChildren = useChildren;
  exports.useCollection = useCollection;
  exports.useField = useField;
  exports.useForm = usePublicContextForm;
  exports.useMultipleForm = useMultipleForm;
  exports.useSelector = useSelector;
  exports.useValidation = useValidation;
  exports.withIndex = withIndex;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
