import { STATUS, FORM_VALIDATION_LABEL } from "./constants";
export var createForm = function createForm(state) {
  if (state === void 0) {
    state = {};
  }

  return {
    state: state,
    isValid: true,
    status: STATUS.READY,
    pristine: true,
    isSubmitting: false,
    submitAttempts: 0,
    submitted: 0
  };
};
export var getValueByPath = function getValueByPath(path, obj, separator) {
  if (separator === void 0) {
    separator = "/";
  }

  if (path === FORM_VALIDATION_LABEL) {
    return obj;
  }

  var properties = Array.isArray(path) ? path : path.split(separator);
  return properties.reduce(function (prev, curr) {
    return prev && prev[curr];
  }, obj);
};
export var isFormValid = function isFormValid(validators, state) {
  return Object.keys(validators).reduce(function (acc, key) {
    var value = getValueByPath(key, state);
    return validators[key](value, state) && acc;
  }, true);
};
export var isFormValidAsync = function isFormValidAsync(validatorsAsync) {
  return Object.keys(validatorsAsync).filter(function (key) {
    return validatorsAsync[key].type === "field";
  }).every(function (key) {
    var _validatorsAsync$key = validatorsAsync[key],
        counter = _validatorsAsync$key.counter,
        isValid = _validatorsAsync$key.isValid;
    return counter === 1 && isValid;
  });
};
export var generateAsynFuncs = function generateAsynFuncs(validators, validatorsMaps, state, updateValidatorsMap) {
  return Object.keys(validators).filter(function (key) {
    var _validatorsMaps$key = validatorsMaps[key],
        type = _validatorsMaps$key.type,
        isValid = _validatorsMaps$key.isValid,
        counter = _validatorsMaps$key.counter;
    return counter === 0 && !isValid && type === "field" || type === "collection";
  }).map(function (key) {
    var value = getValueByPath(key, state);
    return validators[key](value, state).then(function (value) {
      updateValidatorsMap(key, true, 1);
      return value;
    }).catch(function (err) {
      updateValidatorsMap(key, false, 1);
      throw err;
    });
  });
};
export var shouldRunAsyncValidator = function shouldRunAsyncValidator(validatorsMaps) {
  return Object.keys(validatorsMaps).filter(function (key) {
    return validatorsMaps[key].type === "field";
  }).every(function (key) {
    var _validatorsMaps$key2 = validatorsMaps[key],
        isValid = _validatorsMaps$key2.isValid,
        counter = _validatorsMaps$key2.counter;
    return counter === 0 && !isValid || counter === 1 && isValid;
  });
};
export var flatAsyncValidationMap = function flatAsyncValidationMap(asyncInitMap) {
  return Object.keys(asyncInitMap).reduce(function (acc, key) {
    var target = asyncInitMap[key];

    if (typeof target === "function") {
      acc.push(target());
    } else {
      var funcs = flatAsyncValidationMap(target);
      acc.push.apply(acc, funcs);
    }

    return acc;
  }, []);
};
export var fileList = function fileList(files) {
  var fileList = [];

  for (var i = 0, numFiles = files.length; i < numFiles; i++) {
    fileList.push(files[i]);
  }

  return fileList;
};