function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { useRef, useEffect, useCallback, useMemo } from "react";
import { useOwnContext } from "./useOwnContext";
import { useNameProp } from "./commons/useNameProp";
import { useMapFields } from "./useMapFields";
import { useValidators } from "./useValidators";
import { validateProps } from "./../utils/validateProps";
import { updateState } from "./../utils/updateState";
import { chainReducers } from "./../utils/chainReducers";
import { useValidationFunction } from "./commons/useValidationFunction";
import { useValidationFunctionAsync } from "./commons/useValidationFunctionAsync";
import { STATUS } from "./../utils/constants";
import { DISPATCHER_LABEL } from "./../utils/constants";
import { noop } from "./../utils/noop";
var initArray = [];
var initObject = {};
var validatorsDefault = [];
export function useObject(props) {
  var context = useOwnContext();
  var name = props.name,
      index = props.index,
      type = props.type,
      initValue = props.value,
      reducers = props.reducers,
      _props$validators = props.validators,
      validatorsFuncs = _props$validators === void 0 ? validatorsDefault : _props$validators,
      _props$onValidation = props.onValidation,
      onValidation = _props$onValidation === void 0 ? noop : _props$onValidation,
      _props$resetSyncErr = props.resetSyncErr,
      resetSyncErr = _props$resetSyncErr === void 0 ? noop : _props$resetSyncErr,
      _props$resetAsyncErr = props.resetAsyncErr,
      resetAsyncErr = _props$resetAsyncErr === void 0 ? noop : _props$resetAsyncErr,
      asyncValidator = props.asyncValidator,
      _props$onAsyncValidat = props.onAsyncValidation,
      onAsyncValidation = _props$onAsyncValidat === void 0 ? noop : _props$onAsyncValidat,
      _props$touched = props.touched,
      touched = _props$touched === void 0 ? false : _props$touched;

  var _useNameProp = useNameProp(context, name, index),
      nameProp = _useNameProp.nameProp,
      uniqueIDarrayContext = _useNameProp.uniqueIDarrayContext,
      setNameProp = _useNameProp.setNameProp;

  if (process.env.NODE_ENV !== "production") {
    validateProps("<Collection /> ", _extends({}, props, {
      index: nameProp.current
    }), context.type);
  }

  var _useMapFields = useMapFields(nameProp, context, type),
      unRegisterField = _useMapFields.unRegisterField,
      mapFields = _useMapFields.mapFields,
      updateRegisteredField = _useMapFields.updateRegisteredField;

  var applyReducers = useMemo(function () {
    return chainReducers(reducers);
  }, []);
  var isMounted = useRef(false);
  var stillMounted = useCallback(function () {
    return isMounted.current;
  }, []);
  var isArray = type && type === "array";
  var init = initValue || (isArray ? initArray : initObject);
  var state = useRef(init);
  var memoInitialState = useRef(init);
  var prevState = useRef(isArray ? initArray : initObject);
  var valueFieldLastSyncCheck = useRef(null); // getValue from parent context

  if (!isMounted.current) {
    state.current = initValue || context.state[nameProp.current] || init;
  } else {
    state.current = context.state[nameProp.current] || (isArray ? initArray : initObject);
  }

  var formState = useRef(null);
  formState.current = context.formState;
  var resetObj = useRef(isArray ? [] : {});
  var registerReset = useCallback(function (namePropExt, fnReset) {
    resetObj.current = isArray ? [].concat(resetObj.current) : _extends({}, resetObj.current);

    if (isArray && typeof resetObj.current[namePropExt] !== "undefined") {
      resetObj.current.splice(Number(namePropExt), 0, fnReset);
    } else {
      resetObj.current[namePropExt] = fnReset;
    }
  }, []);
  var unRegisterReset = useCallback(function (namePropExt) {
    if (resetObj.current.constructor === Array) {
      resetObj.current.splice(namePropExt, 1);
    } else {
      delete resetObj.current[namePropExt];
    }
  }, []);
  var reset = useCallback(function (formState) {
    valueFieldLastSyncCheck.current = null;
    var initAcc = isArray ? [] : {};
    var obj = Object.keys(resetObj.current).reduce(function (acc, key) {
      var value = resetObj.current[key](formState);
      if (value !== undefined) acc[key] = value;
      return acc;
    }, initAcc);
    var newValue = applyReducers(obj, memoInitialState.current, formState);
    newValue = newValue !== undefined && Object.keys(newValue).length > 0 ? newValue : undefined;
    return newValue;
  }, []);
  var updateParentProps = useCallback(function (nextState) {
    var newState = applyReducers(nextState, state.current, formState.current);
    var removeProp = Object.keys(newState).length === 0;
    context.changeProp(nameProp.current, newState, removeProp);
  }, []);
  var changeProp = useCallback(function (namePropExt, value, removeMe) {
    var nextState = updateState(state.current, {
      value: value,
      nameProp: namePropExt,
      removeMe: removeMe
    });
    updateParentProps(nextState);
  }, []);
  var initProp = useCallback(function (namePropExt, value, intialValue, add) {
    if (add === void 0) {
      add = true;
    }

    var newState = updateState(state.current, {
      value: value,
      nameProp: namePropExt,
      add: isMounted.current && add
    });
    memoInitialState.current = updateState(memoInitialState.current, {
      value: intialValue,
      nameProp: namePropExt,
      add: isMounted.current && add
    });
    var reducedState = applyReducers(newState, state.current, formState.current);
    prevState.current = newState;

    if (isMounted.current) {
      context.initProp(nameProp.current, reducedState, memoInitialState.current, false);
    } else {
      state.current = reducedState;
    }
  }, []);

  var _useRef = useRef(function (namePropExt, _ref, willUnmount) {
    var currentState = _ref.currentState,
        removeCurrent = _ref.removeCurrent,
        initialState = _ref.initialState,
        removeInitial = _ref.removeInitial;

    if (willUnmount === void 0) {
      willUnmount = false;
    }

    var newStateCurrent = updateState(state.current, {
      value: currentState,
      nameProp: namePropExt,
      removeMe: removeCurrent
    });
    var newStateInitial = updateState(memoInitialState.current, {
      value: initialState,
      nameProp: namePropExt,
      removeMe: removeInitial
    });

    if (willUnmount && isArray) {
      newStateCurrent = newStateCurrent.filter(function (elm, index) {
        return index !== namePropExt;
      });
      newStateInitial = newStateInitial.filter(function (elm, index) {
        return index !== namePropExt;
      });
    }

    var reducedState = applyReducers(newStateCurrent, state.current, formState.current);
    state.current = reducedState;
    memoInitialState.current = newStateInitial;
    var removeCurrentProp = Object.keys(state.current).length === 0;
    var removeInitialProp = Object.keys(memoInitialState.current).length === 0;
    context.removeProp(nameProp.current, {
      currentState: state.current,
      removeCurrent: removeCurrentProp,
      initialState: memoInitialState.current,
      removeInitial: removeInitialProp
    });
  }),
      removeProp = _useRef.current;

  var setValue = useCallback(function (resolveNextState) {
    var nextState = typeof resolveNextState === "function" ? resolveNextState(state.current) : resolveNextState;
    updateParentProps(nextState);
  }, []);

  var _useValidators = useValidators(context, nameProp, isMounted),
      validators = _useValidators[0],
      addValidators = _useValidators[1],
      removeValidators = _useValidators[2];

  var _useValidators2 = useValidators(context, nameProp, isMounted, true),
      validatorsAsync = _useValidators2[0],
      addValidatorsAsync = _useValidators2[1],
      removeValidatorsAsync = _useValidators2[2],
      validatorsMapsAsync = _useValidators2[3],
      updateValidatorsMap = _useValidators2[4];

  var _useValidationFunctio = useValidationFunction(validatorsFuncs),
      validationMsg = _useValidationFunctio.validationMsg,
      validationObj = _useValidationFunctio.validationObj,
      validationFN = _useValidationFunctio.validationFN;

  var _useValidationFunctio2 = useValidationFunctionAsync(asyncValidator, onAsyncValidation),
      validationFNAsync = _useValidationFunctio2[0];

  var triggerSyncValidation = useCallback(function (propagate, onSubmit) {
    if (propagate === void 0) {
      propagate = true;
    }

    if (onSubmit === void 0) {
      onSubmit = false;
    }

    if (valueFieldLastSyncCheck.current !== state.current) {
      if (validationObj.current !== null && (touched || onSubmit)) {
        valueFieldLastSyncCheck.current = state.current;
        var _validationObj$curren = validationObj.current,
            isValid = _validationObj$curren.isValid,
            checks = _validationObj$curren.checks;
        onValidation(checks, isValid);
      }

      if (propagate) {
        context == null ? void 0 : context.triggerSyncValidation == null ? void 0 : context.triggerSyncValidation();
      }
    }
  }, []);
  useEffect(function () {
    if (context.formStatus === STATUS.ON_RESET) {
      resetSyncErr();
      resetAsyncErr();
    } else if (context.formStatus !== STATUS.READY && context.formStatus !== STATUS.ON_INIT_ASYNC) {
      if (validationObj.current !== null && context.formStatus === STATUS.ON_SUBMIT) {
        triggerSyncValidation(false, true);
      }

      if (validationObj.current !== null && !validationObj.current.isValid) {
        resetAsyncErr();
      }
    }
  }, [validationMsg.current, context.formStatus]); // used to register async validation Actions

  var asyncInitValidation = useRef({});
  var registerAsyncInitValidation = useCallback(function (nameProp, asyncFunc) {
    asyncInitValidation.current[nameProp] = asyncFunc;
  }, []);
  useEffect(function () {
    isMounted.current = true;

    if (context.type === "array") {
      context.registerIndex(uniqueIDarrayContext, setNameProp);
    } // Add its own validators


    if (validatorsFuncs.length > 0) {
      context.addValidators(nameProp.current, validationFN.current);
    }

    if (typeof asyncValidator === "function") {
      context.addValidatorsAsync(nameProp.current, validationFNAsync.current, null);
    }

    mapFields.current[DISPATCHER_LABEL] = setValue;
    context.updateRegisteredField(nameProp.current, mapFields.current); // register to parent any initial async Validators to be run ON_INIT

    if (Object.keys(asyncInitValidation.current).length > 0) {
      context.registerAsyncInitValidation(nameProp.current, asyncInitValidation.current);
    } // --- Add its own validators --- //
    // Add its children validators


    if (Object.keys(validators.current).length > 0) {
      context.addValidators(nameProp.current, validators.current);
    }

    if (Object.keys(validatorsAsync.current).length > 0) {
      context.addValidatorsAsync(nameProp.current, validatorsAsync.current, validatorsMapsAsync.current);
    } // --- Add the its children validators --- //


    context.registerReset(nameProp.current, reset);
    var newState = applyReducers(state.current, prevState.current, formState.current);
    context.initProp(nameProp.current, newState, memoInitialState.current);
    return function () {
      resetSyncErr();
      resetAsyncErr();
      isMounted.current = false;

      if (context.stillMounted()) {
        context.unRegisterField(nameProp.current); // remove its own by validators

        if (typeof asyncValidator === "function") {
          context.removeValidatorsAsync(nameProp.current, validationFNAsync.current, false);
        }

        if (validatorsFuncs.length > 0) {
          context.removeValidators(nameProp.current, validationFN.current);
        } // ----- remove its own by validators ----- //
        // remove validators inerithed by children


        if (Object.keys(validators.current).length > 0) {
          context.removeValidators(nameProp.current, validators.current);
        }

        if (Object.keys(validatorsAsync.current).length > 0) {
          context.removeValidatorsAsync(nameProp.current, validatorsAsync.current, validatorsMapsAsync.current);
        } // ----- remove validators inerithed by children ----- //


        context.removeProp(nameProp.current, {
          removeCurrent: true,
          removeInitial: true
        }, true);
        context.unRegisterReset(nameProp.current);

        if (context.type === "array") {
          context.removeIndex(uniqueIDarrayContext);
        }
      }
    };
  }, []);
  var childrenIndexes = useRef({});
  var getIndex = useCallback(function (idCpm) {
    if (childrenIndexes.current[idCpm] === undefined) {
      childrenIndexes.current[idCpm] = null;
    }

    return Object.keys(childrenIndexes.current).length - 1;
  }, []);
  var removeIndex = useCallback(function (idCpm) {
    delete childrenIndexes.current[idCpm];
    Object.keys(childrenIndexes.current).forEach(function (idField, index) {
      return childrenIndexes.current[idField](index);
    });
  }, []);
  var registerIndex = useCallback(function (idCpm, fn) {
    childrenIndexes.current[idCpm] = fn;
  }, []);
  return {
    state: state.current,
    // pass the state of the current context down
    formState: context.formState,
    // pass the global form state down
    formStatus: context.formStatus,
    // pass the global form status down
    runAsyncValidation: context.runAsyncValidation,
    unRegisterField: unRegisterField,
    updateRegisteredField: updateRegisteredField,
    registerAsyncInitValidation: registerAsyncInitValidation,
    changeProp: changeProp,
    initProp: initProp,
    removeProp: removeProp,
    stillMounted: stillMounted,
    getIndex: getIndex,
    removeIndex: removeIndex,
    registerIndex: registerIndex,
    type: type,
    addValidators: addValidators,
    removeValidators: removeValidators,
    addValidatorsAsync: addValidatorsAsync,
    removeValidatorsAsync: removeValidatorsAsync,
    updateValidatorsMap: updateValidatorsMap,
    registerReset: registerReset,
    unRegisterReset: unRegisterReset,
    triggerSyncValidation: triggerSyncValidation
  };
}