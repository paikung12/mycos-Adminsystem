function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { useRef, useState, useEffect, useCallback, useMemo } from "react";
import { useValidators } from "./useValidators";
import { useMapFields } from "./useMapFields";
import { useValidationFunction } from "./commons/useValidationFunction";
import { useValidationFunctionAsync } from "./commons/useValidationFunctionAsync";
import { updateState } from "./../utils/updateState";
import { chainReducers } from "./../utils/chainReducers";
import { noop } from "./../utils/noop";
import { STATUS, FORM_VALIDATION_LABEL } from "./../utils/constants";
import { createForm, isFormValid, isFormValidAsync, generateAsynFuncs, shouldRunAsyncValidator, flatAsyncValidationMap } from "./../utils/formUtils";
var emptyStateValue = {};
var validatorsDefault = [];
export function useForm(_ref) {
  var initialState = _ref.initialState,
      touched = _ref.touched,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? noop : _ref$onChange,
      _ref$onReset = _ref.onReset,
      onReset = _ref$onReset === void 0 ? noop : _ref$onReset,
      _ref$onInit = _ref.onInit,
      onInit = _ref$onInit === void 0 ? noop : _ref$onInit,
      _ref$onSubmit = _ref.onSubmit,
      onSubmit = _ref$onSubmit === void 0 ? noop : _ref$onSubmit,
      _ref$onValidation = _ref.onValidation,
      onValidation = _ref$onValidation === void 0 ? noop : _ref$onValidation,
      _ref$resetSyncErr = _ref.resetSyncErr,
      resetSyncErr = _ref$resetSyncErr === void 0 ? noop : _ref$resetSyncErr,
      _ref$validators = _ref.validators,
      validatorsFuncs = _ref$validators === void 0 ? validatorsDefault : _ref$validators,
      _ref$resetAsyncErr = _ref.resetAsyncErr,
      resetAsyncErr = _ref$resetAsyncErr === void 0 ? noop : _ref$resetAsyncErr,
      asyncValidator = _ref.asyncValidator,
      _ref$onAsyncValidatio = _ref.onAsyncValidation,
      onAsyncValidation = _ref$onAsyncValidatio === void 0 ? noop : _ref$onAsyncValidatio,
      reducers = _ref.reducers,
      _getInitilaStateForm_ = _ref._getInitilaStateForm_,
      _onMultipleForm_ = _ref._onMultipleForm_,
      name = _ref.name,
      action = _ref.action;

  var _useState = useState(function () {
    return createForm(initialState);
  }),
      formState = _useState[0],
      dispatch = _useState[1];

  var stateRef = useRef(formState);

  var _useRef = useRef(isUsingMultipleForm(_getInitilaStateForm_, _onMultipleForm_, name)),
      isMultipleForm = _useRef.current;

  var dispatchFormState = useCallback(function (_ref2) {
    var state = _ref2.state,
        status = _ref2.status,
        rest = _objectWithoutPropertiesLoose(_ref2, ["state", "status"]);

    var prevState = status === STATUS.ON_RESET ? memoInitialState.current.state : status === STATUS.ON_INIT ? emptyStateValue : stateRef.current.state;
    var newState = status === STATUS.READY || status === STATUS.ON_SUBMIT ? state : applyReducers(state, prevState, prevState);
    stateRef.current = _extends({}, rest, {
      status: status,
      state: newState
    });
    dispatch(stateRef.current);
  }, []);
  var memoInitialState = useRef(_extends({}, formState));
  var isMounted = useRef(false);
  var stillMounted = useCallback(function () {
    return isMounted.current;
  }, []);

  var _useValidators = useValidators(undefined, undefined, isMounted),
      validators = _useValidators[0],
      addValidators = _useValidators[1],
      removeValidators = _useValidators[2];

  var _useValidationFunctio = useValidationFunction(validatorsFuncs),
      validationMsg = _useValidationFunctio.validationMsg,
      validationObj = _useValidationFunctio.validationObj,
      validationFN = _useValidationFunctio.validationFN;

  var _useValidationFunctio2 = useValidationFunctionAsync(asyncValidator, onAsyncValidation),
      validationFNAsync = _useValidationFunctio2[0];

  var _useValidators2 = useValidators(undefined, undefined, isMounted, true),
      validatorsAsync = _useValidators2[0],
      addValidatorsAsync = _useValidators2[1],
      removeValidatorsAsync = _useValidators2[2],
      validatorsMapsAsync = _useValidators2[3],
      updateValidatorsMap = _useValidators2[4],
      resetValidatorsMap = _useValidators2[5];

  var applyReducers = useMemo(function () {
    return chainReducers(reducers);
  }, []);

  var _useMapFields = useMapFields(),
      unRegisterField = _useMapFields.unRegisterField,
      mapFields = _useMapFields.mapFields,
      updateRegisteredField = _useMapFields.updateRegisteredField;

  var changeProp = useCallback(function (nameProp, value, removeMe) {
    if (removeMe === void 0) {
      removeMe = false;
    }

    var newState = updateState(stateRef.current.state, {
      value: value,
      nameProp: nameProp,
      removeMe: removeMe
    });
    propagateState(newState, false);
  }, []);
  var initProp = useCallback(function (nameProp, value, initialValue) {
    if (isMounted.current) {
      // we must update the memoInitialState with the new prop if form is mounted
      memoInitialState.current.state = updateState(memoInitialState.current.state, {
        isValid: initialValue,
        nameProp: nameProp
      });
      var newState = updateState(stateRef.current.state, {
        value: value,
        nameProp: nameProp
      });
      propagateState(newState, false);
    } else {
      var newStateInitial = updateState(memoInitialState.current.state, {
        value: initialValue,
        nameProp: nameProp
      });

      var _newState = updateState(stateRef.current.state, {
        value: value,
        nameProp: nameProp
      });

      memoInitialState.current.state = newStateInitial;
      stateRef.current.state = _newState;
    }
  }, []);
  var removeProp = useCallback(function (namePropExt, _ref3) {
    var currentState = _ref3.currentState,
        removeCurrent = _ref3.removeCurrent,
        initialState = _ref3.initialState,
        removeInitial = _ref3.removeInitial;
    var newState = updateState(stateRef.current.state, {
      value: currentState,
      nameProp: namePropExt,
      removeMe: removeCurrent
    }); // if a prop removed was also a prop already initialized we must update the memoInitialState

    memoInitialState.current.state = updateState(memoInitialState.current.state, {
      value: initialState,
      nameProp: namePropExt,
      removeMe: removeInitial
    });
    propagateState(newState);
  }, []);
  var propagateState = useCallback(function (state, changePristine, status) {
    if (status === void 0) {
      status = STATUS.ON_CHANGE;
    }

    var pristine = changePristine !== undefined ? changePristine : stateRef.current.pristine;
    var isValid = isFormValid(validators.current, state) && isFormValidAsync(validatorsMapsAsync.current);
    dispatchFormState(_extends({}, stateRef.current, {
      state: state,
      isValid: isValid,
      pristine: pristine,
      status: status
    }));
  }, []);
  var resetObj = useRef({});
  var registerReset = useCallback(function (nameProp, fnReset) {
    var _extends2;

    resetObj.current = _extends({}, resetObj.current, (_extends2 = {}, _extends2[nameProp] = fnReset, _extends2));
  }, []);
  var unRegisterReset = useCallback(function (nameProp) {
    delete resetObj.current[nameProp];
  }, []);
  var reset = useCallback(function () {
    var state = Object.keys(resetObj.current).reduce(function (acc, key) {
      var value = resetObj.current[key](memoInitialState.current.state);
      if (value !== undefined) acc[key] = value;
      return acc;
    }, {});
    var validatorsMapsAsync = resetValidatorsMap();
    var isValid = isFormValid(validators.current, state) && isFormValidAsync(validatorsMapsAsync);
    var status = STATUS.ON_RESET;
    dispatchFormState(_extends({}, memoInitialState.current, {
      state: state,
      status: status,
      isValid: isValid
    }));
  }, []);
  var onSubmitForm = useCallback(function (e) {
    e.persist();
    var _stateRef$current = stateRef.current,
        isValid = _stateRef$current.isValid,
        prevAttempts = _stateRef$current.submitAttempts;
    var status = STATUS.ON_SUBMIT;

    if (typeof action !== "string" || !isValid) {
      e.preventDefault();
    }

    var submitAttempts = prevAttempts + 1;

    if (isValid && Object.keys(validatorsAsync.current).length > 0 && shouldRunAsyncValidator(validatorsMapsAsync.current)) {
      var state = stateRef.current.state;
      var asyncArrayProm = generateAsynFuncs(validatorsAsync.current, validatorsMapsAsync.current, state, updateValidatorsMap);
      var target = e.target;
      e.preventDefault(); // Set isValid to false until it ends the async checks

      dispatchFormState(_extends({}, stateRef.current, {
        isValid: false,
        isSubmitting: true,
        submitAttempts: submitAttempts
      }));
      Promise.all(asyncArrayProm).then(function () {
        if (typeof action === "string") {
          target.submit();
        } else {
          dispatchFormState(_extends({}, stateRef.current, {
            status: status,
            isValid: true
          }));
        }
      }).catch(function () {
        var isValid = shouldRunAsyncValidator(validatorsMapsAsync.current);
        var isSubmitting = false;
        dispatchFormState(_extends({}, stateRef.current, {
          isValid: isValid,
          isSubmitting: isSubmitting
        }));
      });
    } else {
      dispatchFormState(_extends({}, stateRef.current, {
        status: status,
        isSubmitting: true,
        submitAttempts: submitAttempts
      }));
    }
  }, []); // used only to replace the entire Form State

  var dispatchNewState = useCallback(function (nextState) {
    var newState = nextState;

    if (typeof nextState === "function") {
      var currentState = stateRef.current.state;
      newState = nextState(currentState);
    }

    propagateState(newState, false);
  }, []);
  var isFormTouchedOnce = useRef(false);
  var lastStateSyncCheck = useRef(null);
  var triggerSyncValidation = useCallback(function (omitArg1, omitArg2, touchedEventField) {
    if (touchedEventField === void 0) {
      touchedEventField = true;
    }

    if (lastStateSyncCheck.current !== stateRef.current.state && validationObj.current !== null && (isFormTouchedOnce.current || touched && touchedEventField || !touched)) {
      isFormTouchedOnce.current = true;
      lastStateSyncCheck.current = stateRef.current.state;
      var _validationObj$curren = validationObj.current,
          isValid = _validationObj$curren.isValid,
          checks = _validationObj$curren.checks;
      onValidation(checks, isValid);
    }
  }, []); // used to register async validation Actions

  var asyncInitValidation = useRef({});
  var registerAsyncInitValidation = useCallback(function (nameProp, asyncFunc) {
    asyncInitValidation.current[nameProp] = asyncFunc;
  }, []);
  var runInitialAsyncValidators = useCallback(function () {
    var keyAsyncValitions = Object.keys(asyncInitValidation.current);

    if (keyAsyncValitions.length > 0) {
      var status = STATUS.ON_INIT_ASYNC;
      dispatchFormState(_extends({}, stateRef.current, {
        status: status
      }));
      var promises = flatAsyncValidationMap(asyncInitValidation.current);
      Promise.all(promises).then(function () {
        var status = STATUS.READY;
        var isValid = isFormValid(validators.current, stateRef.current.state);
        dispatchFormState(_extends({}, stateRef.current, {
          status: status,
          isValid: isValid
        }));
      }).catch(function () {
        var status = STATUS.READY;
        var isValid = false;
        dispatchFormState(_extends({}, stateRef.current, {
          status: status,
          isValid: isValid
        }));
      });
    }
  }, []);
  var runAsyncValidation = useCallback(function (_ref4) {
    var start = _ref4.start,
        end = _ref4.end;

    if (start) {
      var status = STATUS.ON_RUN_ASYNC;
      dispatchFormState(_extends({}, stateRef.current, {
        isValid: false,
        status: status
      }));
    } else if (end) {
      var _status = STATUS.ON_ASYNC_END;
      var isValid = isFormValid(validators.current, stateRef.current.state) && isFormValidAsync(validatorsMapsAsync.current);
      dispatchFormState(_extends({}, stateRef.current, {
        isValid: isValid,
        status: _status
      }));
    }
  }, []); // change status form to READY after being reset

  useEffect(function () {
    var _stateRef$current2 = stateRef.current,
        status = _stateRef$current2.status,
        state = _stateRef$current2.state,
        isValid = _stateRef$current2.isValid;

    if (status === STATUS.ON_RESET) {
      onReset(state, isValid);
      dispatchFormState(_extends({}, stateRef.current, {
        status: STATUS.RESETTED
      }));
    } else if (status === STATUS.ON_CHANGE) {
      onChange(state, isValid);
    } else if (status === STATUS.ON_INIT) {
      runInitialAsyncValidators();
      onInit(state, isValid);
    } else if (status === STATUS.ON_SUBMIT) {
      var common = {
        isSubmitting: false,
        status: STATUS.READY
      };

      if (isValid) {
        var result = onSubmit(state, isValid);

        if (result && typeof result.then === "function") {
          result.then(function () {
            var submitted = stateRef.current.submitted + 1;
            dispatchFormState(_extends({}, stateRef.current, common, {
              submitted: submitted
            }));
          }).catch(function () {
            return dispatchFormState(_extends({}, stateRef.current, common));
          });
        } else {
          var prevSub = stateRef.current.submitted;
          var submitted = result === false ? prevSub : prevSub + 1;
          dispatchFormState(_extends({}, stateRef.current, common, {
            submitted: submitted
          }));
        }
      } else {
        dispatchFormState(_extends({}, stateRef.current, common));
      }
    }

    if (isMultipleForm && (status === STATUS.ON_RESET || status === STATUS.ON_CHANGE || status === STATUS.ON_INIT || status === STATUS.ON_SUBMIT)) {
      _onMultipleForm_(name, state);
    }
  }, [stateRef.current]); // after form is mounted dispatch the initial state

  useEffect(function () {
    isMounted.current = true; // Add its own validators

    if (validatorsFuncs.length > 0) {
      addValidators(FORM_VALIDATION_LABEL, validationFN.current);
    } // Add its own async validator func


    if (typeof asyncValidator === "function") {
      addValidatorsAsync(FORM_VALIDATION_LABEL, validationFNAsync.current, null);
    }

    var pristine = isMultipleForm && (_getInitilaStateForm_(name) == undefined || Object.keys(_getInitilaStateForm_(name)).length === 0) || !isMultipleForm;
    var state = isMultipleForm ? _getInitilaStateForm_(name) || stateRef.current.state : stateRef.current.state;
    var isValid = isFormValid(validators.current, state) && isFormValidAsync(validatorsMapsAsync.current);
    stateRef.current = _extends({}, stateRef.current, {
      state: state,
      isValid: isValid,
      pristine: pristine,
      status: STATUS.ON_INIT
    });
    dispatchFormState(stateRef.current);
  }, []);
  useEffect(function () {
    var formStatus = formState.status;

    if (formStatus === STATUS.ON_RESET) {
      isFormTouchedOnce.current = false;
      lastStateSyncCheck.current = false;
      resetSyncErr();
      resetAsyncErr();
    } else if (formStatus !== STATUS.READY && formStatus !== STATUS.ON_INIT_ASYNC) {
      if (validationObj.current !== null) {
        triggerSyncValidation(false, true, false);
      }

      if (validationObj.current !== null && !validationObj.current.isValid) {
        resetAsyncErr();
      }
    }
  }, [validationMsg.current, formState.status]);
  return _extends({}, formState, {
    // { isValid, state, status, pristine, isSubmitting }
    formState: formState.state,
    // pass the global form state down
    formStatus: formState.status,
    // pass the global form status down
    mapFields: mapFields.current,
    triggerSyncValidation: triggerSyncValidation,
    unRegisterField: unRegisterField,
    updateRegisteredField: updateRegisteredField,
    registerAsyncInitValidation: registerAsyncInitValidation,
    runAsyncValidation: runAsyncValidation,
    dispatchNewState: dispatchNewState,
    changeProp: changeProp,
    initProp: initProp,
    onSubmitForm: onSubmitForm,
    removeProp: removeProp,
    stillMounted: stillMounted,
    reset: reset,
    addValidators: addValidators,
    removeValidators: removeValidators,
    addValidatorsAsync: addValidatorsAsync,
    removeValidatorsAsync: removeValidatorsAsync,
    updateValidatorsMap: updateValidatorsMap,
    registerReset: registerReset,
    unRegisterReset: unRegisterReset
  });
}

function isUsingMultipleForm(_getInitilaStateForm_, _onMultipleForm_, name) {
  return typeof _getInitilaStateForm_ === "function" && typeof _onMultipleForm_ === "function" && typeof name === "string";
}