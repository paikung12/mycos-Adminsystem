function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { useRef, useCallback } from "react";
import { mergeValidators } from "../utils/utilValidators";
export function useValidators(context, nameProp, isMounted, isAsync) {
  if (isAsync === void 0) {
    isAsync = false;
  }

  var validators = useRef({});
  var validatorsMaps = useRef({});
  var updateValidatorsMap = useCallback(function (path, isValid, counter) {
    // It propagates up to the form context
    if (context !== undefined) {
      context.updateValidatorsMap(nameProp.current + "/" + path, isValid, counter);
    } else {
      validatorsMaps.current[path] = _extends({}, validatorsMaps.current[path], {
        isValid: isValid,
        counter: counter
      });
    }
  }, []); // resetValidatorsMap only used in useForm

  var resetValidatorsMap = useCallback(function () {
    Object.keys(validatorsMaps.current).forEach(function (key) {
      var type = validatorsMaps.current[key].type;
      validatorsMaps.current[key].counter = 0;
      validatorsMaps.current[key].isValid = type === "collection" ? null : false;
    });
    return validatorsMaps.current;
  }, []); // syncValidatorsValue type depends on its context - can be function or object
  // asyncValidatorsValue type depends on its context - can be boolean, null or object

  var _useRef = useRef(function (path, syncValidatorsValue, asyncValidatorsValue) {
    validators.current = _extends({}, validators.current, mergeValidators(path, syncValidatorsValue));

    if (isAsync) {
      validatorsMaps.current = _extends({}, validatorsMaps.current, mergeValidators(path, asyncValidatorsValue));
    }

    if (nameProp !== undefined && isMounted.current && context !== undefined) {
      var addFN = isAsync ? context.addValidatorsAsync : context.addValidators;
      addFN(nameProp.current, validators.current, validatorsMaps.current);
    }
  }),
      addValidators = _useRef.current;

  var _useRef2 = useRef(function (path, validatorsToRemove, validatorsMapsToRemove) {
    if (validatorsMapsToRemove === void 0) {
      validatorsMapsToRemove = false;
    }

    var newValidators = _extends({}, validators.current, mergeValidators(path, validatorsToRemove, true));

    var newValidatorsMaps = !isAsync ? {} : _extends({}, validatorsMaps.current, mergeValidators(path, validatorsMapsToRemove, true));

    if (context !== undefined) {
      validators.current = newValidators;
      validatorsMaps.current = newValidatorsMaps;
      var removeFN = isAsync ? context.removeValidatorsAsync : context.removeValidators;
      removeFN(nameProp.current, validators.current, validatorsMaps.current);
    } else {
      // if context is undefined it is the form context and then
      // we must clean the undefined prop from it
      validators.current = cleanValidators(newValidators);
      validatorsMaps.current = cleanValidators(newValidatorsMaps);
    }
  }),
      removeValidators = _useRef2.current;

  return [validators, addValidators, removeValidators, validatorsMaps, updateValidatorsMap, resetValidatorsMap];
}

function cleanValidators(validatorObj) {
  Object.keys(validatorObj).forEach(function (key) {
    if (validatorObj[key] === undefined) {
      delete validatorObj[key];
    }
  });
  return validatorObj;
}