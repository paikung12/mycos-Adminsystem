function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { useEffect, useState, useRef, useCallback, useMemo } from "react";
import { useOwnContext } from "./useOwnContext";
import { useNameProp } from "./commons/useNameProp";
import { useValidationFunction } from "./commons/useValidationFunction";
import { useValidationFunctionAsync } from "./commons/useValidationFunctionAsync";
import { fileList } from "./../utils/formUtils";
import { STATUS } from "./../utils/constants";
import { validateProps } from "./../utils/validateProps";
import { chainReducers } from "./../utils/chainReducers";
import { noop } from "./../utils/noop";
var validatorsDefault = [];
export function useField(props) {
  var context = useOwnContext();
  var name = props.name,
      index = props.index,
      _props$validators = props.validators,
      validators = _props$validators === void 0 ? validatorsDefault : _props$validators,
      asyncValidator = props.asyncValidator,
      type = props.type,
      _props$onFocus = props.onFocus,
      customFocus = _props$onFocus === void 0 ? noop : _props$onFocus,
      _props$onBlur = props.onBlur,
      customBlur = _props$onBlur === void 0 ? noop : _props$onBlur,
      _props$onChange = props.onChange,
      customChange = _props$onChange === void 0 ? noop : _props$onChange,
      _props$onValidation = props.onValidation,
      onValidation = _props$onValidation === void 0 ? noop : _props$onValidation,
      _props$resetSyncErr = props.resetSyncErr,
      resetSyncErr = _props$resetSyncErr === void 0 ? noop : _props$resetSyncErr,
      _props$resetAsyncErr = props.resetAsyncErr,
      resetAsyncErr = _props$resetAsyncErr === void 0 ? noop : _props$resetAsyncErr,
      onAsyncValidation = props.onAsyncValidation,
      _props$value = props.value,
      initialValue = _props$value === void 0 ? "" : _props$value,
      _props$checked = props.checked,
      initialChecked = _props$checked === void 0 ? false : _props$checked,
      _props$touched = props.touched,
      touched = _props$touched === void 0 ? false : _props$touched,
      _props$multiple = props.multiple,
      multiple = _props$multiple === void 0 ? false : _props$multiple,
      reducers = props.reducers;

  var _useNameProp = useNameProp(context, name, index),
      nameProp = _useNameProp.nameProp,
      uniqueIDarrayContext = _useNameProp.uniqueIDarrayContext,
      setNameProp = _useNameProp.setNameProp;

  if (process.env.NODE_ENV !== "production") {
    validateProps("<Input />", _extends({}, props, {
      index: nameProp.current
    }), context.type);
  }

  var state = context.state;
  var formState = useRef(null);
  formState.current = context.formState;
  var isMounted = useRef(false);
  var valueField = useRef(initialValue);
  var checkedField = useRef(initialChecked);
  var fileField = useRef("");
  var valueFieldLastAsyncCheck = useRef(null);
  var valueFieldLastSyncCheck = useRef(null);

  var _getInitialValue = getInitialValue(type, state, nameProp, initialValue, initialChecked, isMounted, context),
      initialValueRef = _getInitialValue[0],
      initialCheckedRef = _getInitialValue[1];

  if (!isMounted.current && initialValueRef.current) {
    valueField.current = initialValueRef.current;
  } else {
    if (type === "checkbox" || type === "radio") {
      valueField.current = initialValueRef.current;
      checkedField.current = type === "checkbox" ? state[nameProp.current] !== undefined || !isMounted.current && initialChecked === true : state[nameProp.current] === initialValueRef.current;
    } else if (type === "select") {
      valueField.current = state[nameProp.current] !== undefined ? state[nameProp.current] : !multiple ? "" : [];
    } else if (type === "file") {
      valueField.current = state[nameProp.current];
      fileField.current = state[nameProp.current] !== undefined ? fileField.current : "";
    } else if (type === "custom") {
      valueField.current = state[nameProp.current];
    } else {
      valueField.current = state[nameProp.current] !== undefined ? state[nameProp.current] : "";
    }
  }

  var applyReducers = useMemo(function () {
    return chainReducers(reducers);
  }, []);
  var reset = useCallback(function (formState) {
    valueFieldLastAsyncCheck.current = null;
    valueFieldLastSyncCheck.current = null;

    switch (type) {
      case "number":
      case "range":
        {
          var val = initialValueRef.current !== "" ? Number(initialValueRef.current) : initialValueRef.current;
          var value = applyReducers(val, valueField.current, formState);
          return value === "" ? undefined : value;
        }

      case "radio":
      case "checkbox":
        {
          checkedField.current = initialCheckedRef.current;
          var _val = initialValueRef.current;

          var _value = applyReducers(_val, valueField.current, formState);

          return initialCheckedRef.current === false ? undefined : _value;
        }

      default:
        {
          var _val2 = initialValueRef.current;

          var _value2 = applyReducers(_val2, valueField.current, formState);

          return _value2 === "" ? undefined : _value2;
        }
    }
  }, []);
  var updateValue = useCallback(function (nextValue, event) {
    var newValue = applyReducers(nextValue, valueField.current, formState.current);
    customChange(newValue, event);
    context.changeProp(nameProp.current, newValue, false);
  }, []);
  var onChange = useCallback(function (event) {
    if (typeof event.persist === "function") {
      event.persist();
    }

    var target = event.target;
    var nextValue;

    if (type === "select" && multiple) {
      var options = target.options;
      nextValue = [];

      for (var i = 0, l = options.length; i < l; i++) {
        if (options[i].selected) {
          nextValue.push(options[i].value);
        }
      }
    } else if (type === "file") {
      nextValue = multiple ? fileList(target.files) : target.files[0];
      fileField.current = target.value;
    } else if (type === "checkbox") {
      nextValue = checkedField.current === true ? "" : initialValueRef.current || target.value || true;
    } else if (type === "radio") {
      nextValue = initialValueRef.current || target.value || true;
    } else if (type === "number" || type === "range") {
      nextValue = target.value !== "" ? Number(target.value) : target.value;
    } else {
      nextValue = target.value;
    }

    updateValue(nextValue, event);
  }, []);
  var setValue = useCallback(function (resolveNextState) {
    var nextValue = typeof resolveNextState === "function" ? resolveNextState(valueField.current) : resolveNextState;
    updateValue(nextValue);
  }, []);
  /* it runs once and set the inital `value` if passed
    and registers the validators functions if there is any
  */

  useEffect(function () {
    isMounted.current = true;

    if (context.type === "array") {
      context.registerIndex(uniqueIDarrayContext, setNameProp);
    }

    if (validators.length > 0) {
      context.addValidators(nameProp.current, validationFN.current);
    } // register field for the useSelector


    context.updateRegisteredField(nameProp.current, setValue); // Adding asyncValidator function and mapping its value as false

    if (typeof asyncValidator === "function") {
      context.addValidatorsAsync(nameProp.current, validationFNAsync.current, false);

      if (initialValue !== "" || initialValueRef.current !== "") {
        context.registerAsyncInitValidation(nameProp.current, function () {
          valueFieldLastAsyncCheck.current = initialValueRef.current;
          return validationFNAsync.current(initialValueRef.current).then(function () {
            context.updateValidatorsMap(nameProp.current, true, 1);
          }).catch(function (err) {
            if (err !== "cancelled") {
              context.updateValidatorsMap(nameProp.current, false, 1);
            }

            throw err;
          });
        });
      }
    }

    if (type === "radio" && initialCheckedRef.current === true) {
      context.registerReset(nameProp.current, reset);
    }

    if (type !== "radio") {
      context.registerReset(nameProp.current, reset);
    }
    /* if a initialValue or initialChecked is passed as prop */


    if (type !== "checkbox" && type !== "radio" && initialValue !== "" || (type === "checkbox" || type === "radio") && initialChecked) {
      // a checkbox might have a value otherwise its value will be true
      var val = initialValue;

      if (type === "checkbox") {
        val = type === "checkbox" ? initialValue || true : initialValue;
      } else if (type === "number" || type === "range") {
        val = Number(val);
      }

      var newValue = applyReducers(val, initialValue, formState.current);
      context.initProp(nameProp.current, newValue, val);
    }

    return function () {
      resetSyncErr();
      resetAsyncErr();

      if (context.stillMounted()) {
        context.unRegisterField(nameProp.current);

        if (typeof asyncValidator === "function") {
          context.removeValidatorsAsync(nameProp.current, validationFNAsync.current);
        }

        if (validators.length > 0) {
          context.removeValidators(nameProp.current, validationFN.current);
        }

        context.removeProp(nameProp.current, {
          removeCurrent: true,
          removeInitial: true
        }, true);
        context.unRegisterReset(nameProp.current);

        if (context.type === "array") {
          context.removeIndex(uniqueIDarrayContext);
        }
      }
    };
  }, []);

  var _useValidationFunctio = useValidationFunction(validators),
      validationMsg = _useValidationFunctio.validationMsg,
      validationObj = _useValidationFunctio.validationObj,
      validationFN = _useValidationFunctio.validationFN;

  var _useValidationFunctio2 = useValidationFunctionAsync(asyncValidator, onAsyncValidation),
      validationFNAsync = _useValidationFunctio2[0];

  var _useState = useState(function () {
    return false;
  }),
      onSyncBlurState = _useState[0],
      setSyncOnBlur = _useState[1];

  var _useState2 = useState(function () {
    return false;
  }),
      onSyncFocusState = _useState2[0],
      setSyncOnFocus = _useState2[1];

  var _useState3 = useState(function () {
    return false;
  }),
      onAsyncBlurState = _useState3[0],
      setAsyncOnBlur = _useState3[1];

  useEffect(function () {
    if (context.formStatus === STATUS.ON_RESET) {
      setSyncOnBlur(false);
      setAsyncOnBlur(false);
      setSyncOnFocus(false);
      resetSyncErr();
      resetAsyncErr();
    } else if (context.formStatus !== STATUS.READY && context.formStatus !== STATUS.ON_INIT_ASYNC) {
      var firstTimeCheck = valueFieldLastSyncCheck.current === null;
      var onlyShowOnSubmit = type === "radio" || type === "checkbox";
      var isCustomCmp = type === "custom";
      var forceOnBlur = type === "select" && multiple;

      if (valueFieldLastSyncCheck.current !== valueField.current && validationObj.current !== null && (!onlyShowOnSubmit && initialValue !== "" || isCustomCmp && touched && onSyncBlurState || context.formStatus === STATUS.ON_SUBMIT || !onlyShowOnSubmit && (touched && onSyncBlurState || !touched && forceOnBlur && (onSyncBlurState || firstTimeCheck) || !touched && !forceOnBlur) || onlyShowOnSubmit && onSyncFocusState)) {
        valueFieldLastSyncCheck.current = valueField.current;
        onValidation(validationObj.current.checks, validationObj.current.isValid);
      }

      if (onSyncBlurState) {
        context == null ? void 0 : context.triggerSyncValidation == null ? void 0 : context.triggerSyncValidation();
      }

      if ((validationObj.current !== null && validationObj.current.isValid || validators.length === 0) && onAsyncBlurState && context.formStatus !== STATUS.ON_SUBMIT && context.formStatus !== STATUS.ON_INIT_ASYNC && typeof asyncValidator === "function") {
        if (valueFieldLastAsyncCheck.current !== valueField.current) {
          valueFieldLastAsyncCheck.current = valueField.current;
          context.runAsyncValidation({
            start: true
          });
          validationFNAsync.current(valueField.current).then(function () {
            context.updateValidatorsMap(nameProp.current, true, 1);
            context.runAsyncValidation({
              end: true
            });
          }).catch(function (err) {
            if (err !== "cancelled") {
              context.updateValidatorsMap(nameProp.current, false, 1);
              context.runAsyncValidation({
                end: true
              });
            }
          });
        }
      }
    }
  }, [validationMsg.current, onSyncBlurState, onAsyncBlurState, onSyncFocusState, context.formStatus]);
  var onBlur = useCallback(function (e) {
    e.persist();
    setAsyncOnBlur(true);
    setSyncOnBlur(true);
    customBlur(e);
  }, []);
  var onFocus = useCallback(function (e) {
    e.persist();
    setSyncOnBlur(false);
    setAsyncOnBlur(false);
    setSyncOnFocus(true);
    customFocus(e);
  }, []);
  var attributes = filterProps({
    onChange: onChange,
    onBlur: onBlur,
    onFocus: onFocus,
    checked: checkedField.current,
    value: valueField.current,
    fileValue: fileField.current,
    type: type,
    name: name,
    multiple: multiple,
    setValue: setValue
  });
  return attributes;
}

function filterProps(allProps) {
  switch (allProps.type) {
    case "file":
      {
        var omitVal = allProps.value,
            _omitSetVal = allProps.setValue,
            fileValue = allProps.fileValue,
            _props = _objectWithoutPropertiesLoose(allProps, ["value", "setValue", "fileValue"]);

        return _extends({}, _props, {
          value: fileValue
        });
      }

    case "select":
      {
        var omitType = allProps.type,
            _omitSetVal2 = allProps.setValue,
            _omitFileVal = allProps.fileValue,
            _props2 = _objectWithoutPropertiesLoose(allProps, ["type", "setValue", "fileValue"]);

        return _props2;
      }

    case "custom":
      {
        var omitfileVal = allProps.fileValue,
            _props3 = _objectWithoutPropertiesLoose(allProps, ["fileValue"]);

        return _props3;
      }

    default:
      var omitFileVal = allProps.fileValue,
          omitSetVal = allProps.setValue,
          props = _objectWithoutPropertiesLoose(allProps, ["fileValue", "setValue"]);

      return props;
  }
}

function getInitialValue(type, state, nameProp, initialValue, initialChecked, isMounted, context) {
  var initValueRef = initialValue;
  var initCheckRef = initialChecked;

  if (state[nameProp.current] !== undefined && !isMounted.current && !context.stillMounted()) {
    if (type !== "radio" && initValueRef === "") {
      initValueRef = state[nameProp.current];
    }

    if (initialChecked === false && (type === "checkbox" || type === "radio" && state[nameProp.current] === initialValue)) {
      initCheckRef = true;
    }
  }

  var initialValueRef = useRef(initValueRef);
  var initialCheckedRef = useRef(initCheckRef);
  return [initialValueRef, initialCheckedRef];
}