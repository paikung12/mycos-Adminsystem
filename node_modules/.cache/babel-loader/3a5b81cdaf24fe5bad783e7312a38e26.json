{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport { useRef, useCallback } from \"react\";\nimport { mergeValidators } from \"../utils/utilValidators\";\nexport function useValidators(context, nameProp, isMounted, isAsync) {\n  if (isAsync === void 0) {\n    isAsync = false;\n  }\n\n  var validators = useRef({});\n  var validatorsMaps = useRef({});\n  var updateValidatorsMap = useCallback(function (path, isValid, counter) {\n    // It propagates up to the form context\n    if (context !== undefined) {\n      context.updateValidatorsMap(nameProp.current + \"/\" + path, isValid, counter);\n    } else {\n      validatorsMaps.current[path] = _extends({}, validatorsMaps.current[path], {\n        isValid: isValid,\n        counter: counter\n      });\n    }\n  }, []); // resetValidatorsMap only used in useForm\n\n  var resetValidatorsMap = useCallback(function () {\n    Object.keys(validatorsMaps.current).forEach(function (key) {\n      var type = validatorsMaps.current[key].type;\n      validatorsMaps.current[key].counter = 0;\n      validatorsMaps.current[key].isValid = type === \"collection\" ? null : false;\n    });\n    return validatorsMaps.current;\n  }, []); // syncValidatorsValue type depends on its context - can be function or object\n  // asyncValidatorsValue type depends on its context - can be boolean, null or object\n\n  var _useRef = useRef(function (path, syncValidatorsValue, asyncValidatorsValue) {\n    validators.current = _extends({}, validators.current, mergeValidators(path, syncValidatorsValue));\n\n    if (isAsync) {\n      validatorsMaps.current = _extends({}, validatorsMaps.current, mergeValidators(path, asyncValidatorsValue));\n    }\n\n    if (nameProp !== undefined && isMounted.current && context !== undefined) {\n      var addFN = isAsync ? context.addValidatorsAsync : context.addValidators;\n      addFN(nameProp.current, validators.current, validatorsMaps.current);\n    }\n  }),\n      addValidators = _useRef.current;\n\n  var _useRef2 = useRef(function (path, validatorsToRemove, validatorsMapsToRemove) {\n    if (validatorsMapsToRemove === void 0) {\n      validatorsMapsToRemove = false;\n    }\n\n    var newValidators = _extends({}, validators.current, mergeValidators(path, validatorsToRemove, true));\n\n    var newValidatorsMaps = !isAsync ? {} : _extends({}, validatorsMaps.current, mergeValidators(path, validatorsMapsToRemove, true));\n\n    if (context !== undefined) {\n      validators.current = newValidators;\n      validatorsMaps.current = newValidatorsMaps;\n      var removeFN = isAsync ? context.removeValidatorsAsync : context.removeValidators;\n      removeFN(nameProp.current, validators.current, validatorsMaps.current);\n    } else {\n      // if context is undefined it is the form context and then\n      // we must clean the undefined prop from it\n      validators.current = cleanValidators(newValidators);\n      validatorsMaps.current = cleanValidators(newValidatorsMaps);\n    }\n  }),\n      removeValidators = _useRef2.current;\n\n  return [validators, addValidators, removeValidators, validatorsMaps, updateValidatorsMap, resetValidatorsMap];\n}\n\nfunction cleanValidators(validatorObj) {\n  Object.keys(validatorObj).forEach(function (key) {\n    if (validatorObj[key] === undefined) {\n      delete validatorObj[key];\n    }\n  });\n  return validatorObj;\n}","map":{"version":3,"sources":["/Users/auttapongkompiban/Spec_mycos/mycos-makub/node_modules/usetheform/build/es/hooks/useValidators.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","useRef","useCallback","mergeValidators","useValidators","context","nameProp","isMounted","isAsync","validators","validatorsMaps","updateValidatorsMap","path","isValid","counter","undefined","current","resetValidatorsMap","keys","forEach","type","_useRef","syncValidatorsValue","asyncValidatorsValue","addFN","addValidatorsAsync","addValidators","_useRef2","validatorsToRemove","validatorsMapsToRemove","newValidators","newValidatorsMaps","removeFN","removeValidatorsAsync","removeValidators","cleanValidators","validatorObj"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport { useRef, useCallback } from \"react\";\nimport { mergeValidators } from \"../utils/utilValidators\";\nexport function useValidators(context, nameProp, isMounted, isAsync) {\n  if (isAsync === void 0) {\n    isAsync = false;\n  }\n\n  var validators = useRef({});\n  var validatorsMaps = useRef({});\n  var updateValidatorsMap = useCallback(function (path, isValid, counter) {\n    // It propagates up to the form context\n    if (context !== undefined) {\n      context.updateValidatorsMap(nameProp.current + \"/\" + path, isValid, counter);\n    } else {\n      validatorsMaps.current[path] = _extends({}, validatorsMaps.current[path], {\n        isValid: isValid,\n        counter: counter\n      });\n    }\n  }, []); // resetValidatorsMap only used in useForm\n\n  var resetValidatorsMap = useCallback(function () {\n    Object.keys(validatorsMaps.current).forEach(function (key) {\n      var type = validatorsMaps.current[key].type;\n      validatorsMaps.current[key].counter = 0;\n      validatorsMaps.current[key].isValid = type === \"collection\" ? null : false;\n    });\n    return validatorsMaps.current;\n  }, []); // syncValidatorsValue type depends on its context - can be function or object\n  // asyncValidatorsValue type depends on its context - can be boolean, null or object\n\n  var _useRef = useRef(function (path, syncValidatorsValue, asyncValidatorsValue) {\n    validators.current = _extends({}, validators.current, mergeValidators(path, syncValidatorsValue));\n\n    if (isAsync) {\n      validatorsMaps.current = _extends({}, validatorsMaps.current, mergeValidators(path, asyncValidatorsValue));\n    }\n\n    if (nameProp !== undefined && isMounted.current && context !== undefined) {\n      var addFN = isAsync ? context.addValidatorsAsync : context.addValidators;\n      addFN(nameProp.current, validators.current, validatorsMaps.current);\n    }\n  }),\n      addValidators = _useRef.current;\n\n  var _useRef2 = useRef(function (path, validatorsToRemove, validatorsMapsToRemove) {\n    if (validatorsMapsToRemove === void 0) {\n      validatorsMapsToRemove = false;\n    }\n\n    var newValidators = _extends({}, validators.current, mergeValidators(path, validatorsToRemove, true));\n\n    var newValidatorsMaps = !isAsync ? {} : _extends({}, validatorsMaps.current, mergeValidators(path, validatorsMapsToRemove, true));\n\n    if (context !== undefined) {\n      validators.current = newValidators;\n      validatorsMaps.current = newValidatorsMaps;\n      var removeFN = isAsync ? context.removeValidatorsAsync : context.removeValidators;\n      removeFN(nameProp.current, validators.current, validatorsMaps.current);\n    } else {\n      // if context is undefined it is the form context and then\n      // we must clean the undefined prop from it\n      validators.current = cleanValidators(newValidators);\n      validatorsMaps.current = cleanValidators(newValidatorsMaps);\n    }\n  }),\n      removeValidators = _useRef2.current;\n\n  return [validators, addValidators, removeValidators, validatorsMaps, updateValidatorsMap, resetValidatorsMap];\n}\n\nfunction cleanValidators(validatorObj) {\n  Object.keys(validatorObj).forEach(function (key) {\n    if (validatorObj[key] === undefined) {\n      delete validatorObj[key];\n    }\n  });\n  return validatorObj;\n}"]},"metadata":{},"sourceType":"module"}